<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonymous Chatrooms</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
    }

    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5)); }
      50% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.8)); }
    }

    .glow {
      animation: glow 2s ease-in-out infinite;
    }

    .glow-text {
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.4);
    }

    .glow-border {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.1);
    }

    .glow-button {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }

    .glow-button:hover {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
      background: #fff !important;
      color: #000 !important;
    }

    input:focus, textarea:focus {
      outline: none;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .message-bubble {
      transition: all 0.3s ease;
      position: relative;
    }

    .message-bubble:hover {
      transform: translateY(-2px);
    }

    .message-bubble:hover .message-actions {
      opacity: 1;
      pointer-events: auto;
    }

    .message-actions {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      position: absolute;
      top: -5px;
      right: 5px;
      display: flex;
      gap: 5px;
      z-index: 10;
    }

    .action-btn {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }

    .action-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      transform: scale(1.1);
    }

    .emoji-picker {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 5px;
      margin-bottom: 5px;
      box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .emoji-btn {
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.2s;
    }

    .emoji-btn:hover {
      background: #2a2a2a;
      transform: scale(1.2);
    }

    .reaction-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 8px;
    }

    .reaction {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 4px 10px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reaction:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .reaction.active {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      font-weight: bold;
    }

    .typing-indicator {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px 15px;
      margin-bottom: 10px;
      font-size: 13px;
      color: #999;
      font-style: italic;
    }

    .system-message {
      text-align: center;
      color: #666;
      font-size: 13px;
      font-style: italic;
      padding: 8px;
      margin: 10px 0;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }

    .video-call-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: flex;
      flex-direction: column;
    }

    .video-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 20px;
    }

    .remote-video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }

    .local-video {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 150px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }

    .call-controls {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .call-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 24px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .call-btn:hover {
      transform: scale(1.1);
    }

    .call-btn.end {
      background: #ff3b30;
      color: #fff;
    }

    .call-btn.mute {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .call-btn.video-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .incoming-call {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a1a;
      padding: 40px;
      border-radius: 20px;
      border: 2px solid #fff;
      text-align: center;
      z-index: 10001;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
    }

    .call-status {
      text-align: center;
      font-size: 18px;
      color: #fff;
      margin-bottom: 20px;
    }

    .reply-preview {
      background: rgba(255, 255, 255, 0.05);
      border-left: 3px solid #666;
      padding: 10px 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      font-size: 13px;
    }

    .reply-to {
      background: rgba(255, 255, 255, 0.05);
      border-left: 3px solid currentColor;
      padding: 6px 10px;
      margin-bottom: 8px;
      border-radius: 3px;
      font-size: 12px;
      opacity: 0.8;
    }

    .debug-console {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      z-index: 999;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .debug-log {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 6px;
      border-left: 3px solid;
    }

    .debug-log.info { border-color: #4a9eff; background: rgba(74, 158, 255, 0.1); }
    .debug-log.success { border-color: #00ff00; background: rgba(0, 255, 0, 0.1); }
    .debug-log.error { border-color: #ff0000; background: rgba(255, 0, 0, 0.1); }
    .debug-log.warning { border-color: #ffaa00; background: rgba(255, 170, 0, 0.1); }

    .debug-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #333;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 998;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .debug-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
    }

    /* Minimized window styles */
    .minimized-window {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      z-index: 900;
      transition: all 0.3s ease;
    }

    .minimized-window.maximized {
      width: 90vw;
      height: 90vh;
      bottom: 5vh;
      right: 5vw;
      z-index: 950;
    }

    .minimized-window-header {
      background: #1a1a1a;
      padding: 10px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: move;
      border-bottom: 1px solid #333;
    }

    .minimized-window-title {
      font-size: 14px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .minimized-window-controls {
      display: flex;
      gap: 8px;
    }

    .window-btn {
      background: transparent;
      border: none;
      color: #999;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
      font-size: 16px;
      line-height: 1;
    }

    .window-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .minimized-window-content {
      height: 200px;
      overflow: hidden;
    }

    .minimized-window.maximized .minimized-window-content {
      height: calc(90vh - 50px);
    }

    .game-iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const firebaseConfig = {
      apiKey: "AIzaSyCR9UiBA6mg3J5a6WGtPK9F76E_ul1D1_c",
      authDomain: "chatroom-60410.firebaseapp.com",
      databaseURL: "https://chatroom-60410-default-rtdb.firebaseio.com",
      projectId: "chatroom-60410",
      storageBucket: "chatroom-60410.firebasestorage.app",
      messagingSenderId: "1074130659134",
      appId: "1:1074130659134:web:06b77a69a0c1d2ee47ee6f",
      measurementId: "G-ENN9HEXNDB"
    };

    let db = null;
    const debugLogs = [];
    
    const addDebugLogGlobal = (message, type = 'info') => {
      const timestamp = new Date().toLocaleTimeString();
      debugLogs.push({ message, type, timestamp });
      if (debugLogs.length > 50) debugLogs.shift();
      console.log(`[${type.toUpperCase()}] ${message}`);
    };

    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
        addDebugLogGlobal('Firebase initialized', 'success');
      }
      db = firebase.database();
      addDebugLogGlobal('Database connection established', 'success');
    } catch (error) {
      addDebugLogGlobal(`Firebase error: ${error.message}`, 'error');
    }

    const EMOJIS = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üò°', 'üéâ', 'üî•', 'üëÄ', 'üíØ', 'üôè', '‚ú®'];

    const MessageCircle = () => <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>;
    const Send = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>;
    const LogOut = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>;
    const Plus = () => <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
    const Trash = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>;
    const Users = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>;
    const UserX = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="8.5" cy="7" r="4"/><line x1="18" y1="8" x2="23" y2="13"/><line x1="23" y1="8" x2="18" y2="13"/></svg>;
    const Gamepad = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><line x1="15" y1="13" x2="15.01" y2="13"/><line x1="18" y1="11" x2="18.01" y2="11"/><rect x="2" y="6" width="20" height="12" rx="2"/></svg>;
    const Bug = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="8" y="6" width="8" height="14" rx="4"/><path d="M6 12h4m8 0h4M8 6V4a2 2 0 0 1 4 0v2m4 0V4a2 2 0 0 1 4 0v2M8 18v2a2 2 0 0 0 4 0v-2m4 0v2a2 2 0 0 0 4 0v-2"/></svg>;
    const Smile = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>;

    // Minimized Window Component
    const MinimizedWindow = ({ title, url, onClose, icon }) => {
      const [isMaximized, setIsMaximized] = useState(false);
      const [position, setPosition] = useState({ x: window.innerWidth - 320, y: window.innerHeight - 250 });
      const [isDragging, setIsDragging] = useState(false);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

      const handleMouseDown = (e) => {
        if (e.target.closest('.window-btn')) return;
        setIsDragging(true);
        setDragOffset({
          x: e.clientX - position.x,
          y: e.clientY - position.y
        });
      };

      const handleMouseMove = (e) => {
        if (isDragging && !isMaximized) {
          setPosition({
            x: e.clientX - dragOffset.x,
            y: e.clientY - dragOffset.y
          });
        }
      };

      const handleMouseUp = () => {
        setIsDragging(false);
      };

      useEffect(() => {
        if (isDragging) {
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
          };
        }
      }, [isDragging, dragOffset]);

      return (
        <div 
          className={`minimized-window ${isMaximized ? 'maximized' : ''}`}
          style={!isMaximized ? { 
            left: `${position.x}px`, 
            top: `${position.y}px`,
            right: 'auto',
            bottom: 'auto'
          } : {}}
        >
          <div 
            className="minimized-window-header"
            onMouseDown={handleMouseDown}
          >
            <div className="minimized-window-title">
              <span>{icon}</span>
              <span>{title}</span>
            </div>
            <div className="minimized-window-controls">
              <button 
                className="window-btn" 
                onClick={() => setIsMaximized(!isMaximized)}
                title={isMaximized ? "Minimize" : "Maximize"}
              >
                {isMaximized ? 'üóó' : 'üóñ'}
              </button>
              <button 
                className="window-btn" 
                onClick={onClose}
                title="Close"
              >
                ‚úï
              </button>
            </div>
          </div>
          <div className="minimized-window-content">
            <iframe 
              src={url} 
              className="game-iframe"
              title={title}
              allow="camera; microphone; fullscreen"
            />
          </div>
        </div>
      );
    };

    const DebugConsole = ({ logs, onClose }) => (
      <div className="debug-console">
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <strong>üêõ Debug Console</strong>
          <button onClick={onClose} style={{ background: 'transparent', border: 'none', color: '#999', cursor: 'pointer', fontSize: '18px' }}>√ó</button>
        </div>
        <div style={{ marginBottom: '10px', padding: '10px', background: '#1a1a1a', borderRadius: '8px', fontSize: '12px' }}>
          <strong style={{ color: '#4CAF50' }}>üìã Browser Console Instructions:</strong>
          <div style={{ marginTop: '5px', color: '#999' }}>
            Press <strong style={{ color: '#fff' }}>F12</strong> or <strong style={{ color: '#fff' }}>Ctrl+Shift+I</strong> (Windows) / <strong style={{ color: '#fff' }}>Cmd+Option+I</strong> (Mac)
          </div>
          <div style={{ color: '#999' }}>
            Click the <strong style={{ color: '#fff' }}>"Console"</strong> tab to see detailed camera & snap debugging
          </div>
        </div>
        <div>
          {logs.slice(-20).map((log, i) => (
            <div key={i} className={`debug-log ${log.type}`}>
              <div style={{ fontSize: '10px', color: '#666', marginBottom: '2px' }}>{new Date(log.timestamp).toLocaleTimeString()}</div>
              <div>{log.message}</div>
            </div>
          ))}
        </div>
      </div>
    );

    function ChatroomApp() {
      const [username, setUsername] = useState('');
      const [tempUsername, setTempUsername] = useState('');
      const [currentView, setCurrentView] = useState('start');
      const [currentRoom, setCurrentRoom] = useState(null);
      const [rooms, setRooms] = useState([]);
      const [messages, setMessages] = useState([]);
      const [message, setMessage] = useState('');
      const [newRoomName, setNewRoomName] = useState('');
      const [newRoomPassword, setNewRoomPassword] = useState('');
      const [error, setError] = useState('');
      const [roomUsers, setRoomUsers] = useState([]);
      const [typingUsers, setTypingUsers] = useState([]);
      const [replyTo, setReplyTo] = useState(null);
      const [showEmojiPicker, setShowEmojiPicker] = useState(null);
      const [logs, setLogs] = useState([]);
      const [showDebug, setShowDebug] = useState(false);
      const [showCamera, setShowCamera] = useState(false);
      const [cameraReady, setCameraReady] = useState(false);
      const [showImageInput, setShowImageInput] = useState(false);
      const [imageUrl, setImageUrl] = useState('');
      const [showGamesMenu, setShowGamesMenu] = useState(false);
      const [gameInvite, setGameInvite] = useState(null);
      const [openGameWindows, setOpenGameWindows] = useState([]);
      const [inCall, setInCall] = useState(false);
      const [callWith, setCallWith] = useState(null);
      const [incomingCall, setIncomingCall] = useState(null);
      const [localStream, setLocalStream] = useState(null);
      const [remoteStream, setRemoteStream] = useState(null);
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoOff, setIsVideoOff] = useState(false);

      const messagesEndRef = useRef(null);
      const typingTimeoutRef = useRef(null);
      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const localVideoRef = useRef(null);
      const remoteVideoRef = useRef(null);
      const peerConnectionRef = useRef(null);

      const addDebugLog = (message, type = 'info') => {
        addDebugLogGlobal(message, type);
      };

      useEffect(() => {
        const interval = setInterval(() => {
          setLogs([...debugLogs]);
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      useEffect(() => {
        if (db) {
          const connectedRef = db.ref('.info/connected');
          connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
              addDebugLog('Firebase connected', 'success');
            } else {
              addDebugLog('Firebase disconnected', 'error');
            }
          });
          return () => connectedRef.off();
        }
      }, []);

      useEffect(() => {
        if (db) {
          const roomsRef = db.ref('rooms');
          const handleRooms = (snapshot) => {
            const data = snapshot.val();
            setRooms(data ? Object.values(data) : []);
            addDebugLog(`Rooms loaded: ${data ? Object.keys(data).length : 0}`, 'info');
          };
          roomsRef.on('value', handleRooms);
          return () => roomsRef.off('value', handleRooms);
        }
      }, []);

      useEffect(() => {
        if (username && currentRoom && db) {
          addDebugLog(`Joined room ${currentRoom}`, 'success');
          const userRef = db.ref(`roomUsers/${currentRoom}/${username}`);
          userRef.set(Date.now());
          userRef.onDisconnect().remove();

          const usersRef = db.ref(`roomUsers/${currentRoom}`);
          const handleUsers = (snapshot) => {
            const data = snapshot.val();
            setRoomUsers(data ? Object.keys(data) : []);
          };
          usersRef.on('value', handleUsers);

          const typingRef = db.ref(`typing/${currentRoom}`);
          const handleTyping = (snapshot) => {
            const data = snapshot.val();
            if (data) {
              const now = Date.now();
              const activeTypers = Object.entries(data)
                .filter(([user, time]) => user !== username && now - time < 3000)
                .map(([user]) => user);
              setTypingUsers(activeTypers);
            } else {
              setTypingUsers([]);
            }
          };
          const typingInterval = setInterval(() => typingRef.once('value', handleTyping), 1000);

          return () => {
            usersRef.off('value', handleUsers);
            clearInterval(typingInterval);
            userRef.remove();
          };
        }
      }, [username, currentRoom]);

      useEffect(() => {
        if (currentRoom && db) {
          const messagesRef = db.ref(`messages/${currentRoom}`);
          const handleMessages = (snapshot) => {
            const data = snapshot.val();
            setMessages(data ? Object.values(data).sort((a, b) => a.timestamp - b.timestamp) : []);
          };
          messagesRef.on('value', handleMessages);
          return () => messagesRef.off('value', handleMessages);
        }
      }, [currentRoom]);

      useEffect(() => {
        if (currentRoom && db) {
          const inviteRef = db.ref(`gameInvites/${currentRoom}`);
          const handleInvite = (snapshot) => {
            const data = snapshot.val();
            setGameInvite(data);
          };
          inviteRef.on('value', handleInvite);
          return () => inviteRef.off('value', handleInvite);
        }
      }, [currentRoom]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      useEffect(() => {
        if (username && currentRoom) {
          addDebugLog(`Joined room ${currentRoom}`, 'success');
          const userRef = db.ref(`roomUsers/${currentRoom}/${username}`);
          userRef.set(Date.now());
          userRef.onDisconnect().remove();

          const usersRef = db.ref(`roomUsers/${currentRoom}`);
          const handleUsers = (snapshot) => {
            const data = snapshot.val();
            setRoomUsers(data ? Object.keys(data) : []);
          };
          usersRef.on('value', handleUsers);

          const typingRef = db.ref(`typing/${currentRoom}`);
          const handleTyping = (snapshot) => {
            const data = snapshot.val();
            if (data) {
              const now = Date.now();
              const activeTypers = Object.entries(data)
                .filter(([user, time]) => user !== username && now - time < 3000)
                .map(([user]) => user);
              setTypingUsers(activeTypers);
            } else {
              setTypingUsers([]);
            }
          };
          const typingInterval = setInterval(() => typingRef.once('value', handleTyping), 1000);

          return () => {
            usersRef.off('value', handleUsers);
            clearInterval(typingInterval);
            userRef.remove();
          };
        }
      }, [username, currentRoom]);

      useEffect(() => {
        const roomsRef = db.ref('rooms');
        const handleRooms = (snapshot) => {
          const data = snapshot.val();
          setRooms(data ? Object.values(data) : []);
        };
        roomsRef.on('value', handleRooms);
        return () => roomsRef.off('value', handleRooms);
      }, []);

      useEffect(() => {
        if (currentRoom) {
          const messagesRef = db.ref(`messages/${currentRoom}`);
          const handleMessages = (snapshot) => {
            const data = snapshot.val();
            const msgs = data ? Object.values(data).sort((a, b) => a.timestamp - b.timestamp) : [];
            console.log('=== MESSAGES LOADED FROM FIREBASE ===');
            console.log('Total messages:', msgs.length);
            const snapMessages = msgs.filter(m => m.type === 'snap');
            console.log('Snap messages:', snapMessages.length);
            snapMessages.forEach((snap, i) => {
              console.log(`Snap ${i + 1}:`, {
                id: snap.id,
                username: snap.username,
                hasImage: !!snap.image,
                imageType: typeof snap.image,
                imageLength: snap.image?.length,
                imageStart: snap.image?.substring(0, 30)
              });
            });
            setMessages(msgs);
          };
          messagesRef.on('value', handleMessages);
          return () => messagesRef.off('value', handleMessages);
        }
      }, [currentRoom]);

      useEffect(() => {
        if (currentRoom) {
          const inviteRef = db.ref(`gameInvites/${currentRoom}`);
          const handleInvite = (snapshot) => {
            const data = snapshot.val();
            setGameInvite(data);
          };
          inviteRef.on('value', handleInvite);
          return () => inviteRef.off('value', handleInvite);
        }
      }, [currentRoom]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      const startCamera = async () => {
        console.log('=== CAMERA START DEBUG ===');
        console.log('Time:', new Date().toLocaleTimeString());
        
        // Clean up any existing stream first
        if (videoRef.current?.srcObject) {
          console.log('Cleaning up existing stream...');
          const tracks = videoRef.current.srcObject.getTracks();
          tracks.forEach(track => track.stop());
          videoRef.current.srcObject = null;
        }
        
        setCameraReady(false);
        
        try {
          console.log('Requesting camera access...');
          const startTime = Date.now();
          
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'user',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
          
          const accessTime = Date.now() - startTime;
          console.log(`‚úÖ Camera access granted! Took ${accessTime}ms`);
          console.log('Stream:', stream);
          console.log('Video tracks:', stream.getVideoTracks());
          console.log('Track state:', stream.getVideoTracks()[0]?.readyState);
          console.log('Track enabled:', stream.getVideoTracks()[0]?.enabled);
          
          if (videoRef.current) {
            console.log('Setting srcObject...');
            videoRef.current.srcObject = stream;
            console.log('Stream assigned to video element');
            
            // Set a timeout to warn if video doesn't load
            const loadTimeout = setTimeout(() => {
              console.error('‚ö†Ô∏è WARNING: Video has not loaded after 5 seconds!');
              console.error('Video readyState:', videoRef.current?.readyState);
              console.error('Video dimensions:', videoRef.current?.videoWidth, 'x', videoRef.current?.videoHeight);
              console.error('Video networkState:', videoRef.current?.networkState);
              console.error('Video paused:', videoRef.current?.paused);
              console.error('Video error:', videoRef.current?.error);
            }, 5000);
            
            // Wait for video to actually load
            videoRef.current.onloadedmetadata = () => {
              clearTimeout(loadTimeout);
              const loadTime = Date.now() - startTime;
              console.log(`‚úÖ Video metadata loaded! Took ${loadTime}ms total`);
              console.log('Video dimensions:', videoRef.current.videoWidth, 'x', videoRef.current.videoHeight);
              console.log('Video readyState:', videoRef.current.readyState);
              if (videoRef.current.videoWidth > 0 && videoRef.current.videoHeight > 0) {
                setCameraReady(true);
                console.log('‚úÖ CAMERA IS READY TO SNAP!');
              } else {
                console.error('‚ùå Video dimensions are still 0x0!');
              }
            };
            
            videoRef.current.oncanplay = () => {
              console.log('‚úÖ Video can play now!');
              console.log('Video readyState:', videoRef.current.readyState);
              setCameraReady(true);
              console.log('‚úÖ Camera ready set from oncanplay');
            };
            
            videoRef.current.onerror = (e) => {
              console.error('‚ùå VIDEO ERROR:', e);
              console.error('Video error details:', videoRef.current?.error);
            };
            
            // Force play if needed
            console.log('Calling video.play()...');
            try {
              await videoRef.current.play();
              console.log('‚úÖ Video play() succeeded');
            } catch (playErr) {
              console.warn('‚ö†Ô∏è Video play() failed (may autoplay):', playErr);
            }
          } else {
            console.error('‚ùå videoRef.current is null!');
          }
          setShowCamera(true);
          addDebugLog('Camera started', 'success');
          console.log('=== CAMERA START COMPLETE ===');
        } catch (err) {
          console.error('=== CAMERA ERROR ===');
          console.error('Error:', err);
          console.error('Error name:', err.name);
          console.error('Error message:', err.message);
          setError('Camera access denied: ' + err.message);
          addDebugLog(`Camera error: ${err.message}`, 'error');
        }
      };

      const stopCamera = () => {
        console.log('=== STOPPING CAMERA ===');
        if (videoRef.current) {
          // Stop all tracks
          if (videoRef.current.srcObject) {
            const tracks = videoRef.current.srcObject.getTracks();
            console.log('Stopping tracks:', tracks.length);
            tracks.forEach(track => {
              track.stop();
              console.log('Track stopped:', track.kind);
            });
          }
          
          // Clear all event handlers
          videoRef.current.onloadedmetadata = null;
          videoRef.current.oncanplay = null;
          videoRef.current.onerror = null;
          
          // Clear srcObject
          videoRef.current.srcObject = null;
          console.log('Video srcObject cleared');
        }
        setShowCamera(false);
        setCameraReady(false);
        addDebugLog('Camera stopped', 'info');
        console.log('=== CAMERA STOPPED ===');
      };

      const takeSnap = async () => {
        console.log('=== SNAP DEBUG START ===');
        console.log('videoRef.current:', videoRef.current);
        console.log('canvasRef.current:', canvasRef.current);
        
        if (!videoRef.current || !canvasRef.current) {
          console.error('Missing refs!');
          addDebugLog('Snap failed: missing refs', 'error');
          return;
        }
        
        const canvas = canvasRef.current;
        const video = videoRef.current;
        
        console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
        console.log('Video readyState:', video.readyState);
        
        // Check if video is ready and has dimensions
        if (video.videoWidth === 0 || video.videoHeight === 0) {
          console.error('Video not ready! Dimensions are 0x0');
          setError('Video not ready yet. Wait a moment and try again.');
          addDebugLog('Snap failed: video not ready', 'error');
          return;
        }
        
        if (video.readyState < 2) {
          console.error('Video readyState too low:', video.readyState);
          setError('Video still loading. Please wait a moment.');
          addDebugLog('Snap failed: video still loading', 'error');
          return;
        }
        
        // Resize to max 800px width to reduce file size
        const maxWidth = 800;
        const scale = Math.min(1, maxWidth / video.videoWidth);
        canvas.width = video.videoWidth * scale;
        canvas.height = video.videoHeight * scale;
        
        console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
        console.log('Scale:', scale);
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        console.log('Image drawn to canvas');
        
        // Compress more aggressively (0.5 quality)
        const imageData = canvas.toDataURL('image/jpeg', 0.5);
        
        console.log('Image data URL length:', imageData.length);
        console.log('Image data preview:', imageData.substring(0, 50) + '...');
        console.log('Estimated size (KB):', (imageData.length * 0.75 / 1024).toFixed(2));
        
        // Additional check - make sure we have actual image data
        if (imageData.length < 100) {
          console.error('Image data too short! Something went wrong with capture.');
          setError('Failed to capture image. Please try again.');
          addDebugLog('Snap failed: image data too short', 'error');
          return;
        }
        
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const newMsg = {
          id: msgId,
          username,
          type: 'snap',
          image: imageData,
          timestamp: Date.now(),
          reactions: {}
        };
        
        console.log('Message object created:', {
          id: newMsg.id,
          username: newMsg.username,
          type: newMsg.type,
          imageLength: newMsg.image.length,
          timestamp: newMsg.timestamp
        });
        console.log('Current room:', currentRoom);
        console.log('Firebase path:', `messages/${currentRoom}/${msgId}`);
        
        try {
          console.log('Attempting to send to Firebase...');
          await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
          console.log('‚úÖ SUCCESS! Snap sent to Firebase');
          addDebugLog('Snap sent', 'success');
          stopCamera();
        } catch (err) {
          console.error('‚ùå FIREBASE ERROR:', err);
          console.error('Error message:', err.message);
          console.error('Error code:', err.code);
          console.error('Full error:', err);
          setError('Failed to send snap: ' + err.message);
          addDebugLog(`Snap send error: ${err.message}`, 'error');
        }
        
        console.log('=== SNAP DEBUG END ===');
      };

      const sendImageUrl = async () => {
        console.log('=== IMAGE URL SEND DEBUG ===');
        console.log('Image URL:', imageUrl);
        console.log('Current room:', currentRoom);
        console.log('Username:', username);
        
        if (!imageUrl.trim() || !currentRoom || !username) {
          console.error('Missing required data!');
          return;
        }
        
        let finalImageUrl = imageUrl.trim();
        
        // Convert Giphy page URLs to media URLs
        if (finalImageUrl.includes('giphy.com/gifs/')) {
          console.log('Detected Giphy page URL, converting...');
          // Extract the GIF ID from URLs like: https://giphy.com/gifs/spongebob-boi-breathe-in-Mp4YvyzWMpXCWAD7mX
          const gifIdMatch = finalImageUrl.match(/gifs\/[^\/]+-([A-Za-z0-9]+)$/);
          if (gifIdMatch) {
            const gifId = gifIdMatch[1];
            // Convert to media URL
            finalImageUrl = `https://media.giphy.com/media/${gifId}/giphy.gif`;
            console.log('Converted to media URL:', finalImageUrl);
          }
        }
        
        // Also handle tenor URLs
        if (finalImageUrl.includes('tenor.com/view/')) {
          console.log('Detected Tenor page URL - please use "Copy GIF Link" instead');
          setError('For Tenor, right-click the GIF and select "Copy image address"');
          return;
        }
        
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const newMsg = {
          id: msgId,
          username,
          type: 'snap',
          image: finalImageUrl,
          timestamp: Date.now(),
          reactions: {}
        };
        
        console.log('Message object:', newMsg);
        console.log('Firebase path:', `messages/${currentRoom}/${msgId}`);
        
        try {
          console.log('Sending to Firebase...');
          await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
          console.log('‚úÖ SUCCESS! Image URL sent');
          addDebugLog('Image sent', 'success');
          setImageUrl('');
          setShowImageInput(false);
        } catch (err) {
          console.error('‚ùå FIREBASE ERROR:', err);
          console.error('Error message:', err.message);
          setError('Failed to send image: ' + err.message);
          addDebugLog(`Image send error: ${err.message}`, 'error');
        }
        
        console.log('=== IMAGE URL SEND END ===');
      };

      // Video Call Functions
      const startCall = async (targetUser) => {
        try {
          console.log('Starting call with:', targetUser);
          
          // Get local media stream
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
          });
          setLocalStream(stream);
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }

          // Create peer connection
          const configuration = {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          };
          const peerConnection = new RTCPeerConnection(configuration);
          peerConnectionRef.current = peerConnection;

          // Add local tracks to peer connection
          stream.getTracks().forEach(track => {
            peerConnection.addTrack(track, stream);
          });

          // Handle incoming tracks
          peerConnection.ontrack = (event) => {
            console.log('Received remote track');
            setRemoteStream(event.streams[0]);
            if (remoteVideoRef.current) {
              remoteVideoRef.current.srcObject = event.streams[0];
            }
          };

          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              db.ref(`calls/${currentRoom}/${targetUser}/candidates/${username}`).push({
                candidate: event.candidate.toJSON()
              });
            }
          };

          // Create and send offer
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          await db.ref(`calls/${currentRoom}/${targetUser}/offer`).set({
            from: username,
            offer: offer.toJSON(),
            timestamp: Date.now()
          });

          setInCall(true);
          setCallWith(targetUser);
          addDebugLog(`Calling ${targetUser}...`, 'info');

          // Listen for answer
          db.ref(`calls/${currentRoom}/${username}/answer`).on('value', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.from === targetUser) {
              const answer = new RTCSessionDescription(data.answer);
              await peerConnection.setRemoteDescription(answer);
              console.log('Answer received and set');
            }
          });

          // Listen for ICE candidates from remote peer
          db.ref(`calls/${currentRoom}/${username}/candidates/${targetUser}`).on('child_added', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.candidate) {
              await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
          });

        } catch (err) {
          console.error('Error starting call:', err);
          setError('Failed to start call: ' + err.message);
          addDebugLog(`Call error: ${err.message}`, 'error');
        }
      };

      const answerCall = async (caller) => {
        try {
          console.log('Answering call from:', caller);
          
          // Get local media stream
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
          });
          setLocalStream(stream);
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }

          // Create peer connection
          const configuration = {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          };
          const peerConnection = new RTCPeerConnection(configuration);
          peerConnectionRef.current = peerConnection;

          // Add local tracks
          stream.getTracks().forEach(track => {
            peerConnection.addTrack(track, stream);
          });

          // Handle incoming tracks
          peerConnection.ontrack = (event) => {
            console.log('Received remote track');
            setRemoteStream(event.streams[0]);
            if (remoteVideoRef.current) {
              remoteVideoRef.current.srcObject = event.streams[0];
            }
          };

          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              db.ref(`calls/${currentRoom}/${caller}/candidates/${username}`).push({
                candidate: event.candidate.toJSON()
              });
            }
          };

          // Set remote description from offer
          const offerData = incomingCall.offer;
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));

          // Create and send answer
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);

          await db.ref(`calls/${currentRoom}/${caller}/answer`).set({
            from: username,
            answer: answer.toJSON(),
            timestamp: Date.now()
          });

          setInCall(true);
          setCallWith(caller);
          setIncomingCall(null);
          addDebugLog(`In call with ${caller}`, 'success');

          // Listen for ICE candidates from remote peer
          db.ref(`calls/${currentRoom}/${username}/candidates/${caller}`).on('child_added', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.candidate) {
              await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
          });

        } catch (err) {
          console.error('Error answering call:', err);
          setError('Failed to answer call: ' + err.message);
          setIncomingCall(null);
        }
      };

      const endCall = () => {
        console.log('Ending call');
        
        // Stop all tracks
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
        }
        
        // Close peer connection
        if (peerConnectionRef.current) {
          peerConnectionRef.current.close();
          peerConnectionRef.current = null;
        }

        // Clean up Firebase
        if (currentRoom && username) {
          db.ref(`calls/${currentRoom}/${username}`).remove();
          db.ref(`calls/${currentRoom}/${callWith}`).remove();
        }

        setInCall(false);
        setCallWith(null);
        setLocalStream(null);
        setRemoteStream(null);
        setIsMuted(false);
        setIsVideoOff(false);
        addDebugLog('Call ended', 'info');
      };

      const toggleMute = () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            setIsMuted(!audioTrack.enabled);
          }
        }
      };

      const toggleVideo = () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            setIsVideoOff(!videoTrack.enabled);
          }
        }
      };

      const declineCall = () => {
        if (incomingCall) {
          db.ref(`calls/${currentRoom}/${incomingCall.from}/declined`).set(true);
        }
        setIncomingCall(null);
      };

      // Listen for incoming calls
      useEffect(() => {
        if (username && currentRoom && db) {
          const callRef = db.ref(`calls/${currentRoom}/${username}/offer`);
          callRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.from !== username && !inCall) {
              setIncomingCall(data);
            }
          });
          return () => callRef.off();
        }
      }, [username, currentRoom, inCall]);

      const updateTyping = () => {
        if (!currentRoom || !username || !db) return;
        db.ref(`typing/${currentRoom}/${username}`).set(Date.now());
        if (typingTimeoutRef.current) {
          clearTimeout(typingTimeoutRef.current);
        }
        typingTimeoutRef.current = setTimeout(() => {
          db.ref(`typing/${currentRoom}/${username}`).remove();
        }, 3000);
      };

      const createRoom = async () => {
        if (!newRoomName.trim()) {
          setError('Room name required');
          addDebugLog('Room creation failed: name required', 'error');
          return;
        }
        const roomId = Date.now().toString();
        const room = {
          id: roomId,
          name: newRoomName.trim(),
          password: newRoomPassword,
          createdAt: Date.now(),
          owner: username
        };
        try {
          await db.ref(`rooms/${roomId}`).set(room);
          addDebugLog(`Room created: ${newRoomName}`, 'success');
          setCurrentRoom(roomId);
          setNewRoomName('');
          setNewRoomPassword('');
          setError('');
          setCurrentView('room');
        } catch (err) {
          setError('Failed to create room');
          addDebugLog(`Room creation error: ${err.message}`, 'error');
        }
      };

      // Game invite handlers
      const sendGameInvite = async (gameType) => {
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        try {
          await db.ref(`gameInvites/${currentRoom}`).set({
            sender: username,
            gameType: gameType,
            timestamp: Date.now()
          });
          addDebugLog(`Sent ${gameType} invite`, 'success');
          setShowGamesMenu(false);
        } catch (err) {
          addDebugLog(`Game invite error: ${err.message}`, 'error');
        }
      };

      const acceptGameInvite = async () => {
        if (!gameInvite) return;
        
        const gameUrls = {
          'gartic': 'https://garlicphone.vercel.app',
          'uno': 'https://unoonline-delta.vercel.app'
        };

        const gameIcons = {
          'gartic': 'üé®',
          'uno': 'üÉè'
        };

        const gameTitles = {
          'gartic': 'Gartic Phone',
          'uno': 'Uno Online'
        };

        const url = gameUrls[gameInvite.gameType];
        if (url) {
          const newWindow = {
            id: Date.now().toString(),
            title: gameTitles[gameInvite.gameType],
            url: url,
            icon: gameIcons[gameInvite.gameType]
          };
          setOpenGameWindows(prev => [...prev, newWindow]);
        }
        
        await db.ref(`gameInvites/${currentRoom}`).remove();
        setGameInvite(null);
      };

      const declineGameInvite = async () => {
        await db.ref(`gameInvites/${currentRoom}`).remove();
        setGameInvite(null);
      };

      const closeGameWindow = (windowId) => {
        setOpenGameWindows(prev => prev.filter(w => w.id !== windowId));
      };

      const joinRoom = (room, password = '') => {
        if (room.password && room.password !== password) {
          setError('Incorrect password');
          addDebugLog(`Failed to join ${room.name}: wrong password`, 'error');
          return;
        }
        setCurrentRoom(room.id);
        setCurrentView('room');
        setError('');
        addDebugLog(`Joining room: ${room.name}`, 'info');
      };

      const sendMessage = async () => {
        if (!message.trim() || !currentRoom || !username) return;
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const newMsg = {
          id: msgId,
          username,
          text: message,
          timestamp: Date.now(),
          reactions: {},
          ...(replyTo && { replyTo: replyTo.id })
        };
        try {
          await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
          setMessage('');
          setReplyTo(null);
          addDebugLog('Message sent', 'success');
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
            db.ref(`typing/${currentRoom}/${username}`).remove();
          }
        } catch (err) {
          setError('Failed to send message');
          addDebugLog(`Message send error: ${err.message}`, 'error');
        }
      };

      const addReaction = async (messageId, emoji) => {
        if (!currentRoom || !db) return;
        try {
          const reactionPath = `messages/${currentRoom}/${messageId}/reactions/${emoji}`;
          const reactionRef = db.ref(reactionPath);
          const snapshot = await reactionRef.once('value');
          const users = snapshot.val() || [];
          if (users.includes(username)) {
            const newUsers = users.filter(u => u !== username);
            if (newUsers.length === 0) {
              await reactionRef.remove();
            } else {
              await reactionRef.set(newUsers);
            }
            addDebugLog(`Removed reaction ${emoji}`, 'info');
          } else {
            await reactionRef.set([...users, username]);
            addDebugLog(`Added reaction ${emoji}`, 'success');
          }
        } catch (err) {
          addDebugLog(`Reaction error: ${err.message}`, 'error');
        }
      };

      const clearAllMessages = async () => {
        const currentRoomData = rooms.find(r => r.id === currentRoom);
        if (!currentRoomData || currentRoomData.owner !== username) {
          alert('‚ùå Only the room owner can clear messages!');
          addDebugLog('Clear messages denied: not owner', 'warning');
          return;
        }
        if (!confirm('‚ö†Ô∏è Clear all messages in this room?')) return;
        try {
          await db.ref(`messages/${currentRoom}`).remove();
          addDebugLog('All messages cleared', 'success');
        } catch (err) {
          setError('Failed to clear messages');
          addDebugLog(`Clear messages error: ${err.message}`, 'error');
        }
      };
  
      const kickUser = async (targetUser) => {
        const currentRoomData = rooms.find(r => r.id === currentRoom);
        if (!currentRoomData || (currentRoomData.owner !== username && username !== 'emmaowner')) {
          alert('‚ùå Only the room owner can kick users!');
          addDebugLog('Kick denied: not owner', 'warning');
          return;
        }
        if (!confirm(`‚ö†Ô∏è Kick ${targetUser} from the room?`)) return;
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const systemMsg = {
          id: msgId,
          type: 'system',
          text: `${targetUser} was kicked from the room`,
          timestamp: Date.now()
        };
        try {
          await db.ref(`messages/${currentRoom}/${msgId}`).set(systemMsg);
          await db.ref(`roomUsers/${currentRoom}/${targetUser}`).remove();
          addDebugLog(`Kicked user: ${targetUser}`, 'success');
        } catch (err) {
          setError('Failed to kick user');
          addDebugLog(`Kick error: ${err.message}`, 'error');
        }
      };

      const leaveRoom = async () => {
        if (!currentRoom || !username) return;
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const systemMsg = {
          id: msgId,
          type: 'system',
          text: `${username} left the room`,
          timestamp: Date.now()
        };
        try {
          await db.ref(`messages/${currentRoom}/${msgId}`).set(systemMsg);
          await db.ref(`roomUsers/${currentRoom}/${username}`).remove();
          addDebugLog('Left room', 'info');
        } catch (err) {
          addDebugLog(`Leave room error: ${err.message}`, 'error');
        }
        setCurrentRoom(null);
        setCurrentView('lobby');
        setMessages([]);
      };

      const deleteRoom = async (roomId, e) => {
        e.stopPropagation();
        const room = rooms.find(r => r.id === roomId);
        if (room && room.owner !== username && username !== 'emmaowner') {
          alert('‚ùå Only the room owner can delete this room!');
          addDebugLog('Delete denied: not owner', 'warning');
          return;
        }
        if (!confirm('‚ö†Ô∏è Delete this room and all messages?')) return;
        try {
          await db.ref(`rooms/${roomId}`).remove();
          await db.ref(`messages/${roomId}`).remove();
          await db.ref(`roomUsers/${roomId}`).remove();
          await db.ref(`typing/${roomId}`).remove();
          addDebugLog(`Room deleted: ${room.name}`, 'success');
        } catch (err) {
          setError('Failed to delete room');
          addDebugLog(`Delete room error: ${err.message}`, 'error');
        }
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      };

      const getReplyMessage = (replyToId) => {
        return messages.find(m => m.id === replyToId);
      };

      if (currentView === 'start') {
        return (
          <>
            <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', borderRadius: '20px', padding: '40px', width: '100%', maxWidth: '400px', border: '1px solid #333' }}>
                <div style={{ textAlign: 'center', marginBottom: '30px' }}>
                  <div className="glow" style={{ display: 'inline-block' }}><MessageCircle /></div>
                  <h1 className="glow-text" style={{ fontSize: '32px', fontWeight: 'bold', marginTop: '20px', marginBottom: '10px' }}>CHATROOMS</h1>
                  <p style={{ color: '#999' }}>Enter the void</p>
                </div>
                <input
                  type="text"
                  value={tempUsername}
                  onChange={(e) => setTempUsername(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && tempUsername.trim() && (setUsername(tempUsername.trim()), setCurrentView('lobby'))}
                  placeholder="Choose username..."
                  style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '20px' }}
                />
                <div style={{ display: 'grid', gap: '10px' }}>
                  <button onClick={() => tempUsername.trim() ? (setUsername(tempUsername.trim()), setCurrentView('lobby')) : setError('Enter a username')} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>JOIN ROOM</button>
                  <button onClick={() => tempUsername.trim() ? (setUsername(tempUsername.trim()), setCurrentView('create')) : setError('Enter a username')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE ROOM</button>
                </div>
                {error && <div style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', marginTop: '15px' }}>{error}</div>}
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'create') {
        return (
          <>
            <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', borderRadius: '20px', padding: '40px', width: '100%', maxWidth: '500px', border: '1px solid #333' }}>
                <div style={{ textAlign: 'center', marginBottom: '30px' }}>
                  <div className="glow" style={{ display: 'inline-block' }}><Plus /></div>
                  <h1 className="glow-text" style={{ fontSize: '28px', fontWeight: 'bold', marginTop: '20px', marginBottom: '10px' }}>CREATE ROOM</h1>
                  <p style={{ color: '#999' }}>User: {username}</p>
                </div>
                <input type="text" value={newRoomName} onChange={(e) => setNewRoomName(e.target.value)} placeholder="Room name..." style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '15px' }} />
                <input type="password" value={newRoomPassword} onChange={(e) => setNewRoomPassword(e.target.value)} placeholder="Password (optional)..." style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '20px' }} />
                <div style={{ display: 'grid', gap: '10px' }}>
                  <button onClick={createRoom} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE & ENTER</button>
                  <button onClick={() => setCurrentView('lobby')} style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>BACK</button>
                </div>
                {error && <div style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', marginTop: '15px' }}>{error}</div>}
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'lobby') {
        return (
          <>
            <div style={{ minHeight: '100vh', padding: '20px' }}>
              <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                <div style={{ textAlign: 'center', marginBottom: '40px' }}>
                  <h1 className="glow-text" style={{ fontSize: '36px', fontWeight: 'bold', marginBottom: '10px' }}>ACTIVE ROOMS</h1>
                  <p style={{ color: '#999', fontSize: '16px' }}>User: {username}</p>
                </div>
                <div style={{ display: 'grid', gap: '15px', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))' }}>
                  {rooms.length === 0 ? (
                    <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '60px 20px', background: '#0a0a0a', borderRadius: '15px', border: '1px solid #333' }}>
                      <p style={{ color: '#666', fontSize: '18px', marginBottom: '20px' }}>No rooms yet. Create one!</p>
                      <button onClick={() => setCurrentView('create')} className="glow-button" style={{ background: '#fff', color: '#000', padding: '15px 30px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE ROOM</button>
                    </div>
                  ) : (
                    rooms.map(room => (
                      <div key={room.id} className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderRadius: '15px', border: '1px solid #333', display: 'flex', flexDirection: 'column', gap: '15px' }}>
                        <div>
                          <h3 style={{ fontSize: '20px', fontWeight: 'bold', marginBottom: '8px' }}>{room.name}</h3>
                          <div style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#999', fontSize: '13px', flexWrap: 'wrap' }}>
                            <span>by {room.owner}</span>
                            {room.password && <span style={{ background: '#1a1a1a', padding: '4px 8px', borderRadius: '6px', border: '1px solid #333' }}>üîí Private</span>}
                          </div>
                        </div>
                        <div style={{ display: 'flex', gap: '10px' }}>
                          <button onClick={() => room.password ? (() => {
                            const pwd = prompt('Enter password:');
                            if (pwd !== null) joinRoom(room, pwd);
                          })() : joinRoom(room)} className="glow-button" style={{ flex: 1, background: '#fff', color: '#000', padding: '12px', borderRadius: '8px', border: 'none', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer' }}>
                            JOIN
                          </button>
                          {(room.owner === username || username === 'emmaowner') && (
                            <button onClick={(e) => deleteRoom(room.id, e)}
                              style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '10px', borderRadius: '8px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '5px' }}>
                              <Trash /> Delete
                            </button>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'room') {
        const currentRoomData = rooms.find(r => r.id === currentRoom);
        const isOwner = currentRoomData && currentRoomData.owner === username;

        return (
          <>
            <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderBottom: '1px solid #333' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '15px' }}>
                  <div>
                    <h2 className="glow-text" style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '5px' }}>
                      {currentRoomData?.name || 'Room'}
                    </h2>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#999', fontSize: '13px' }}>
                      <span>{roomUsers.length} {roomUsers.length === 1 ? 'user' : 'users'} in room</span>
                      {isOwner && <span style={{ background: '#1a1a1a', padding: '4px 10px', borderRadius: '6px', border: '1px solid #333' }}>üëë Owner</span>}
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '10px' }}>
                    {isOwner && (
                      <button onClick={clearAllMessages} style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '10px 20px', borderRadius: '8px', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <Trash /> Clear All
                      </button>
                    )}
                    <button onClick={() => setShowGamesMenu(!showGamesMenu)} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '10px 20px', borderRadius: '8px', border: '1px solid #333', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <Gamepad /> Games
                    </button>
                    <button onClick={leaveRoom} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '10px 20px', borderRadius: '8px', border: '1px solid #333', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <LogOut /> Leave
                    </button>
                  </div>
                </div>
              </div>

              {roomUsers.length > 1 && (
                <div style={{ background: '#0a0a0a', padding: '10px 20px', borderBottom: '1px solid #333' }}>
                  <div style={{ maxWidth: '1200px', margin: '0 auto', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                    <Users style={{ width: '16px', height: '16px' }} />
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {roomUsers.map(user => (
                        <div key={user} style={{ background: '#1a1a1a', padding: '6px 12px', borderRadius: '8px', border: '1px solid #333', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                          <span>{user}</span>
                          {user === currentRoomData?.owner && <span>üëë</span>}
                          {user !== username && !inCall && (
                            <button 
                              onClick={() => startCall(user)} 
                              style={{ 
                                background: 'transparent', 
                                border: 'none', 
                                color: '#00ff88', 
                                cursor: 'pointer', 
                                padding: '0 5px',
                                fontSize: '16px'
                              }}
                              title={`Call ${user}`}
                            >
                              üìû
                            </button>
                          )}
                          {isOwner && user !== username && (
                            <button onClick={() => kickUser(user)} style={{ background: 'transparent', border: 'none', color: '#ff6666', cursor: 'pointer', padding: '0 5px' }}>
                              <UserX style={{ width: '14px', height: '14px' }} />
                            </button>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}

              <div style={{ flex: 1, overflow: 'auto', background: '#000', padding: '20px' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                  
                  {gameInvite && (
                    <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', marginBottom: '20px', borderRadius: '15px', border: '2px solid #4a9eff', animation: 'glow 2s ease-in-out infinite' }}>
                      <div style={{ textAlign: 'center' }}>
                        <div style={{ fontSize: '24px', marginBottom: '10px' }}>üéÆ</div>
                        <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '10px' }}>
                          {gameInvite.sender} wants to play {gameInvite.gameType === 'gartic' ? 'Gartic Phone' : 'Uno'}!
                        </div>
                        <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
                          <button onClick={acceptGameInvite} className="glow-button" style={{ background: '#00ff00', color: '#000', padding: '12px 24px', borderRadius: '8px', border: 'none', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer' }}>
                            ‚úì Accept
                          </button>
                          <button onClick={declineGameInvite} style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '12px 24px', borderRadius: '8px', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold' }}>
                            ‚úï Decline
                          </button>
                        </div>
                      </div>
                    </div>
                  )}

                  {showGamesMenu && (
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setShowGamesMenu(false)}>
                      <div className="glow-border" style={{ background: '#0a0a0a', padding: '30px', borderRadius: '20px', maxWidth: '400px', width: '90%' }} onClick={(e) => e.stopPropagation()}>
                        <h3 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '20px', textAlign: 'center' }}>üéÆ Choose a Game</h3>
                        <div style={{ display: 'grid', gap: '10px' }}>
                          <button onClick={() => sendGameInvite('gartic')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            üé® Gartic Phone
                          </button>
                          <button onClick={() => sendGameInvite('uno')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            üÉè Uno Online
                          </button>
                          <button onClick={() => setShowGamesMenu(false)} style={{ width: '100%', background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            Cancel
                          </button>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  {messages.map((msg) => {
                    if (msg.type === 'system') {
                      return <div key={msg.id} className="system-message">{msg.text}</div>;
                    }

                    if (msg.type === 'snap') {
                      const userColor = `hsl(${msg.username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360}, 70%, 60%)`;
                      console.log('Rendering snap message:', {
                        id: msg.id,
                        username: msg.username,
                        hasImage: !!msg.image,
                        imageLength: msg.image?.length,
                        imagePreview: msg.image?.substring(0, 50)
                      });
                      return (
                        <div key={msg.id} className="message-bubble" style={{ marginBottom: '15px', background: msg.username === username ? '#1a1a1a' : '#0a0a0a', padding: '15px', borderRadius: '15px', border: '1px solid #333' }}>
                          <div style={{ display: 'flex', alignItems: 'baseline', gap: '10px', marginBottom: '8px' }}>
                            <span style={{ color: userColor, fontWeight: 'bold', fontSize: '14px' }}>{msg.username}</span>
                            <span style={{ color: '#666', fontSize: '12px' }}>{formatTime(msg.timestamp)} üì∏</span>
                          </div>
                          {msg.image ? (
                            <img 
                              src={msg.image} 
                              alt="Snap" 
                              style={{ maxWidth: '100%', borderRadius: '10px', marginTop: '10px' }}
                              onLoad={() => console.log('‚úÖ Snap image loaded successfully:', msg.id)}
                              onError={(e) => {
                                console.error('‚ùå Snap image failed to load:', msg.id);
                                console.error('Image src length:', msg.image?.length);
                                console.error('Image src preview:', msg.image?.substring(0, 100));
                                e.target.style.display = 'none';
                                e.target.parentElement.innerHTML += '<div style="background: #2a0000; border: 1px solid #ff0000; color: #ff6666; padding: 15px; borderRadius: 10px; marginTop: 10px;">‚ö†Ô∏è Image failed to load. Check console for details.</div>';
                              }}
                            />
                          ) : (
                            <div style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', marginTop: '10px' }}>
                              ‚ö†Ô∏è No image data found in this snap
                            </div>
                          )}
                          {msg.reactions && Object.keys(msg.reactions).length > 0 && (
                            <div className="reaction-container">
                              {Object.entries(msg.reactions).map(([emoji, users]) => (
                                <div key={emoji} onClick={() => addReaction(msg.id, emoji)} className={`reaction ${users.includes(username) ? 'active' : ''}`}>
                                  <span>{emoji}</span>
                                  <span>{users.length}</span>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      );
                    }

                    const replyMsg = msg.replyTo ? getReplyMessage(msg.replyTo) : null;
                    const userColor = `hsl(${msg.username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360}, 70%, 60%)`;

                    return (
                      <div key={msg.id} className="message-bubble" style={{ marginBottom: '15px', background: msg.username === username ? '#1a1a1a' : '#0a0a0a', padding: '15px', borderRadius: '15px', border: '1px solid #333' }}>
                        <div className="message-actions">
                          <button onClick={() => setReplyTo(msg)} className="action-btn">Reply</button>
                          <button onClick={() => setShowEmojiPicker(showEmojiPicker === msg.id ? null : msg.id)} className="action-btn">
                            <Smile />
                          </button>
                        </div>

                        {showEmojiPicker === msg.id && (
                          <div className="emoji-picker">
                            {EMOJIS.map(emoji => (
                              <button key={emoji} onClick={() => {
                                addReaction(msg.id, emoji);
                                setShowEmojiPicker(null);
                              }} className="emoji-btn">
                                {emoji}
                              </button>
                            ))}
                          </div>
                        )}

                        <div style={{ display: 'flex', alignItems: 'baseline', gap: '10px', marginBottom: '8px' }}>
                          <span style={{ color: userColor, fontWeight: 'bold', fontSize: '14px' }}>{msg.username}</span>
                          <span style={{ color: '#666', fontSize: '12px' }}>{formatTime(msg.timestamp)}</span>
                        </div>

                        {replyMsg && (
                          <div className="reply-to" style={{ borderColor: userColor }}>
                            <div style={{ fontSize: '11px', color: '#999', marginBottom: '4px' }}>Replying to {replyMsg.username}</div>
                            <div style={{ fontSize: '12px', opacity: 0.7 }}>{replyMsg.text.substring(0, 50)}{replyMsg.text.length > 50 ? '...' : ''}</div>
                          </div>
                        )}

                        <div style={{ fontSize: '15px', lineHeight: '1.5', wordBreak: 'break-word' }}>{msg.text}</div>

                        {msg.reactions && Object.keys(msg.reactions).length > 0 && (
                          <div className="reaction-container">
                            {Object.entries(msg.reactions).map(([emoji, users]) => (
                              <div key={emoji} onClick={() => addReaction(msg.id, emoji)} className={`reaction ${users.includes(username) ? 'active' : ''}`}>
                                <span>{emoji}</span>
                                <span>{users.length}</span>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    );
                  })}

                  {typingUsers.length > 0 && (
                    <div className="typing-indicator">
                      {typingUsers.join(', ')} {typingUsers.length === 1 ? 'is' : 'are'} typing...
                    </div>
                  )}

                  <div ref={messagesEndRef} />
                </div>
              </div>

              <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderTop: '1px solid #333' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                  {replyTo && (
                    <div className="reply-preview">
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '5px' }}>
                        <span style={{ fontSize: '12px', color: '#999' }}>Replying to {replyTo.username}</span>
                        <button onClick={() => setReplyTo(null)} style={{ background: 'transparent', border: 'none', color: '#666', cursor: 'pointer', fontSize: '18px', lineHeight: 1 }}>√ó</button>
                      </div>
                      <div style={{ fontSize: '13px', opacity: 0.8 }}>{replyTo.text.substring(0, 80)}{replyTo.text.length > 80 ? '...' : ''}</div>
                    </div>
                  )}

                  {showCamera && (
                    <div style={{ marginBottom: '15px', background: '#1a1a1a', padding: '20px', borderRadius: '15px', border: '1px solid #333' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                        <h3 style={{ fontSize: '16px', fontWeight: 'bold' }}>üì∏ Take a Snap</h3>
                        <button onClick={stopCamera} style={{ background: 'transparent', border: 'none', color: '#999', cursor: 'pointer', fontSize: '24px' }}>√ó</button>
                      </div>
                      {!cameraReady && (
                        <div style={{ marginBottom: '10px', padding: '10px', background: '#1a1a2a', border: '1px solid #4444ff', borderRadius: '8px', color: '#aaaaff', fontSize: '13px', textAlign: 'center' }}>
                          <div style={{ fontSize: '20px', marginBottom: '5px' }}>‚è≥</div>
                          <strong>Loading camera...</strong> Please wait for video to appear
                          <div style={{ marginTop: '10px', fontSize: '11px', color: '#8888ff' }}>
                            If stuck for 10+ seconds, try:<br/>
                            1. Refresh the page<br/>
                            2. Check camera permissions in browser settings<br/>
                            3. Close other apps using the camera<br/>
                            4. Check console (F12) for errors
                          </div>
                        </div>
                      )}
                      {cameraReady && (
                        <div style={{ marginBottom: '10px', padding: '10px', background: '#0a2a0a', border: '1px solid #00ff88', borderRadius: '8px', color: '#88ffcc', fontSize: '13px', textAlign: 'center' }}>
                          <div style={{ fontSize: '20px', marginBottom: '5px' }}>‚úÖ</div>
                          <strong>Camera Ready!</strong> You can now take a snap
                        </div>
                      )}
                      <video ref={videoRef} autoPlay playsInline muted style={{ width: '100%', borderRadius: '10px', marginBottom: '15px', background: '#000' }} />
                      <canvas ref={canvasRef} style={{ display: 'none' }} />
                      <button 
                        onClick={takeSnap} 
                        disabled={!cameraReady}
                        className="glow-button" 
                        style={{ 
                          width: '100%', 
                          background: cameraReady ? '#fff' : '#333', 
                          color: cameraReady ? '#000' : '#666', 
                          padding: '15px', 
                          borderRadius: '10px', 
                          border: 'none', 
                          fontSize: '16px', 
                          fontWeight: 'bold', 
                          cursor: cameraReady ? 'pointer' : 'not-allowed',
                          opacity: cameraReady ? 1 : 0.5
                        }}
                      >
                        {cameraReady ? 'üì∏ SNAP & SEND' : '‚è≥ WAITING FOR CAMERA...'}
                      </button>
                    </div>
                  )}

                  {showImageInput && (
                    <div style={{ marginBottom: '15px', background: '#1a1a1a', padding: '20px', borderRadius: '15px', border: '1px solid #333' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                        <h3 style={{ fontSize: '16px', fontWeight: 'bold' }}>üñºÔ∏è Send Image/GIF</h3>
                        <button onClick={() => setShowImageInput(false)} style={{ background: 'transparent', border: 'none', color: '#999', cursor: 'pointer', fontSize: '24px' }}>√ó</button>
                      </div>
                      <div style={{ marginBottom: '10px', padding: '8px', background: '#0a2a0a', border: '1px solid #00ff88', borderRadius: '8px', color: '#88ffcc', fontSize: '12px' }}>
                        üí° <strong>Tip:</strong> You can paste Giphy page URLs directly! Or use "Share" ‚Üí "Copy GIF Link" from Giphy/Tenor
                      </div>
                      <input
                        type="text"
                        value={imageUrl}
                        onChange={(e) => setImageUrl(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && sendImageUrl()}
                        placeholder="Paste image or GIF URL..."
                        style={{ width: '100%', padding: '15px', background: '#0a0a0a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '15px', marginBottom: '15px' }}
                      />
                      {imageUrl && (
                        <div style={{ marginBottom: '15px', textAlign: 'center' }}>
                          <img src={imageUrl} alt="Preview" style={{ maxWidth: '100%', maxHeight: '200px', borderRadius: '10px' }} onError={(e) => e.target.style.display = 'none'} />
                        </div>
                      )}
                      <button onClick={sendImageUrl} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                        üì§ SEND IMAGE
                      </button>
                    </div>
                  )}

                  <div style={{ display: 'flex', gap: '10px' }}>
                    <input
                      type="text"
                      value={message}
                      onChange={(e) => {
                        setMessage(e.target.value);
                        updateTyping();
                      }}
                      onKeyDown={(e) => e.key === 'Enter' && sendMessage()}
                      placeholder="Type a message..."
                      style={{ flex: 1, padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '15px' }}
                    />
                    <button onClick={sendMessage} className="glow-button" style={{ background: '#fff', color: '#000', padding: '15px 30px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <Send /> Send
                    </button>
                    <button onClick={startCamera} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '15px 30px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                      üì∏
                    </button>
                    <button onClick={() => setShowImageInput(!showImageInput)} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '15px 30px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                      üñºÔ∏è
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {/* Render open game windows */}
            {openGameWindows.map(window => (
              <MinimizedWindow 
                key={window.id}
                title={window.title}
                url={window.url}
                icon={window.icon}
                onClose={() => closeGameWindow(window.id)}
              />
            ))}

            {/* Video Call Modal */}
            {inCall && (
              <div className="video-call-modal">
                <div className="video-container">
                  <video 
                    ref={remoteVideoRef} 
                    autoPlay 
                    playsInline 
                    className="remote-video"
                    style={{ display: remoteStream ? 'block' : 'none' }}
                  />
                  {!remoteStream && (
                    <div className="call-status">
                      <div style={{ fontSize: '48px', marginBottom: '20px' }}>üìû</div>
                      <div>Calling {callWith}...</div>
                      <div style={{ fontSize: '14px', color: '#999', marginTop: '10px' }}>Waiting for them to answer...</div>
                    </div>
                  )}
                  <video 
                    ref={localVideoRef} 
                    autoPlay 
                    playsInline 
                    muted 
                    className="local-video"
                    style={{ display: isVideoOff ? 'none' : 'block' }}
                  />
                  {isVideoOff && (
                    <div className="local-video" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', background: '#1a1a1a' }}>
                      <span style={{ fontSize: '48px' }}>üìπ</span>
                    </div>
                  )}
                  <div className="call-controls">
                    <button 
                      onClick={toggleMute} 
                      className={`call-btn mute ${isMuted ? 'active' : ''}`}
                      title={isMuted ? 'Unmute' : 'Mute'}
                    >
                      {isMuted ? 'üîá' : 'üé§'}
                    </button>
                    <button 
                      onClick={toggleVideo} 
                      className={`call-btn video-toggle ${isVideoOff ? 'active' : ''}`}
                      title={isVideoOff ? 'Turn on camera' : 'Turn off camera'}
                    >
                      {isVideoOff ? 'üìπ' : 'üì∑'}
                    </button>
                    <button 
                      onClick={endCall} 
                      className="call-btn end"
                      title="End call"
                    >
                      ‚òéÔ∏è
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Incoming Call */}
            {incomingCall && !inCall && (
              <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10001 }}>
                <div className="incoming-call">
                  <div style={{ fontSize: '64px', marginBottom: '20px', animation: 'glow 1s ease-in-out infinite' }}>üìû</div>
                  <h2 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '10px' }}>Incoming Call</h2>
                  <p style={{ fontSize: '18px', color: '#999', marginBottom: '30px' }}>{incomingCall.from} is calling you...</p>
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button 
                      onClick={() => answerCall(incomingCall.from)} 
                      className="glow-button" 
                      style={{ 
                        background: '#00ff00', 
                        color: '#000', 
                        padding: '15px 40px', 
                        borderRadius: '50px', 
                        border: 'none', 
                        fontSize: '18px', 
                        fontWeight: 'bold', 
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '10px'
                      }}
                    >
                      üìû Answer
                    </button>
                    <button 
                      onClick={declineCall} 
                      style={{ 
                        background: '#ff3b30', 
                        color: '#fff', 
                        padding: '15px 40px', 
                        borderRadius: '50px', 
                        border: 'none', 
                        fontSize: '18px', 
                        fontWeight: 'bold', 
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '10px'
                      }}
                    >
                      ‚ùå Decline
                    </button>
                  </div>
                </div>
              </div>
            )}

            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      return null;
    }

    ReactDOM.render(<ChatroomApp />, document.getElementById('root'));
  </script>
</body>
</html>
