<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonymous Chatrooms - Group Calls</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
    }

    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5)); }
      50% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.8)); }
    }

    @keyframes slideIn {
      from {
        transform: translateX(-100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .glow {
      animation: glow 2s ease-in-out infinite;
    }

    .glow-text {
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.4);
    }

    .glow-border {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.1);
    }

    .glow-button {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }

    .glow-button:hover {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
      background: #fff !important;
      color: #000 !important;
    }

    input:focus, textarea:focus {
      outline: none;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .message-bubble {
      transition: all 0.3s ease;
      position: relative;
    }

    .message-bubble:hover {
      transform: translateY(-2px);
    }

    .message-bubble:hover .message-actions {
      opacity: 1;
      pointer-events: auto;
    }

    .message-actions {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      position: absolute;
      top: -5px;
      right: 5px;
      display: flex;
      gap: 5px;
      z-index: 10;
    }

    .action-btn {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }

    .action-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      transform: scale(1.1);
    }

    .emoji-picker {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 5px;
      margin-bottom: 5px;
      box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .emoji-btn {
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.2s;
    }

    .emoji-btn:hover {
      background: #2a2a2a;
      transform: scale(1.2);
    }

    .reaction-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 8px;
    }

    .reaction {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 4px 10px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reaction:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .reaction.active {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      font-weight: bold;
    }

    .typing-indicator {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px 15px;
      margin-bottom: 10px;
      font-size: 13px;
      color: #999;
      font-style: italic;
    }

    .system-message {
      text-align: center;
      color: #666;
      font-size: 13px;
      font-style: italic;
      padding: 8px;
      margin: 10px 0;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }

    /* Group Call Styles */
    .group-call-grid {
      display: grid;
      gap: 10px;
      padding: 10px;
      height: calc(100% - 80px);
      width: 100%;
      grid-auto-rows: 1fr;
    }

    .group-call-grid.participants-1 {
      grid-template-columns: 1fr;
    }

    .group-call-grid.participants-2 {
      grid-template-columns: repeat(2, 1fr);
    }

    .group-call-grid.participants-3,
    .group-call-grid.participants-4 {
      grid-template-columns: repeat(2, 1fr);
    }

    .group-call-grid.participants-5,
    .group-call-grid.participants-6 {
      grid-template-columns: repeat(3, 1fr);
    }

    .group-call-grid.participants-7,
    .group-call-grid.participants-8,
    .group-call-grid.participants-9 {
      grid-template-columns: repeat(3, 1fr);
    }

    .participant-video-container {
      position: relative;
      background: #1a1a1a;
      border-radius: 15px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s;
    }

    .participant-video-container:hover {
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .participant-video-container.speaking {
      border-color: #00ff00;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }

    .participant-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .participant-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    .participant-status {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .status-icon {
      font-size: 12px;
    }

    .snap-camera-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 10002;
      display: flex;
      flex-direction: column;
    }

    .snap-video-container {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .snap-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .snap-preview-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .snap-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      align-items: center;
      z-index: 10;
    }

    .snap-capture-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: #fff;
      border: 5px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.2s;
    }

    .snap-capture-btn:active {
      transform: scale(0.95);
    }

    .snap-action-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }

    .snap-action-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .snap-send-btn {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 15px 30px;
      background: #00ff00;
      color: #000;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    }

    .snap-send-btn:hover {
      background: #00dd00;
      transform: scale(1.05);
    }

    .snap-close-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.3);
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 11;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
    }

    .snap-close-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Firebase config - replace with your config
    const firebaseConfig = {
      apiKey: "AIzaSyDW2zvI6kf2-lTIDLtE_e91Kb0dHhqJcmY",
      authDomain: "anonymous-chatrooms-65c01.firebaseapp.com",
      databaseURL: "https://anonymous-chatrooms-65c01-default-rtdb.firebaseio.com",
      projectId: "anonymous-chatrooms-65c01",
      storageBucket: "anonymous-chatrooms-65c01.firebasestorage.app",
      messagingSenderId: "652093992384",
      appId: "1:652093992384:web:f4a4f25ef48ed2f72b28e8"
    };

    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const database = firebase.database();

    // Icons
    const Bug = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <path d="M8 2v4M16 2v4M9 9h.01M15 9h.01M8 13h8M6 8h12a2 2 0 012 2v8a2 2 0 01-2 2H6a2 2 0 01-2-2v-8a2 2 0 012-2z" />
      </svg>
    );

    // Debug Console Component
    function DebugConsole({ logs, onClose }) {
      return (
        <div style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          width: '400px',
          maxHeight: '300px',
          background: 'rgba(0, 0, 0, 0.95)',
          border: '1px solid #333',
          borderRadius: '10px',
          padding: '15px',
          zIndex: 10000,
          backdropFilter: 'blur(10px)'
        }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
            <h3 style={{ fontSize: '14px', color: '#00ff00' }}>Debug Console</h3>
            <button onClick={onClose} style={{
              background: 'transparent',
              border: 'none',
              color: '#fff',
              cursor: 'pointer',
              fontSize: '18px'
            }}>‚úï</button>
          </div>
          <div style={{
            maxHeight: '250px',
            overflowY: 'auto',
            fontSize: '12px',
            fontFamily: 'monospace'
          }}>
            {logs.map((log, i) => (
              <div key={i} style={{
                padding: '4px 0',
                borderBottom: '1px solid #222',
                color: log.type === 'error' ? '#ff4444' : log.type === 'success' ? '#00ff00' : '#999'
              }}>
                <span style={{ color: '#666' }}>[{log.timestamp}]</span> {log.message}
              </div>
            ))}
          </div>
        </div>
      );
    }

    function ChatroomApp() {
      const [username, setUsername] = useState('');
      const [currentRoom, setCurrentRoom] = useState(null);
      const [messages, setMessages] = useState([]);
      const [newMessage, setNewMessage] = useState('');
      const [onlineUsers, setOnlineUsers] = useState([]);
      const [inCall, setInCall] = useState(false);
      const [localStream, setLocalStream] = useState(null);
      const [remoteStreams, setRemoteStreams] = useState({});
      const [peerConnections, setPeerConnections] = useState({});
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoOff, setIsVideoOff] = useState(false);
      const [incomingCall, setIncomingCall] = useState(null);
      const [showSnapCamera, setShowSnapCamera] = useState(false);
      const [capturedSnap, setCapturedSnap] = useState(null);
      const [isFrontCamera, setIsFrontCamera] = useState(true);
      const [captureMode, setCaptureMode] = useState('photo');
      const [isRecording, setIsRecording] = useState(false);
      const [recordedVideo, setRecordedVideo] = useState(null);
      const [recordingTime, setRecordingTime] = useState(0);
      const [notifications, setNotifications] = useState([]);
      const [callParticipants, setCallParticipants] = useState([]);
      const [speakingUsers, setSpeakingUsers] = useState(new Set());
      const [logs, setLogs] = useState([]);
      const [showDebug, setShowDebug] = useState(false);

      const localVideoRef = useRef(null);
      const remoteVideoRefs = useRef({});
      const snapVideoRef = useRef(null);
      const snapCanvasRef = useRef(null);
      const mediaRecorderRef = useRef(null);
      const recordedChunksRef = useRef([]);
      const recordingIntervalRef = useRef(null);
      const messagesEndRef = useRef(null);
      const typingTimeoutRef = useRef(null);

      const addLog = (message, type = 'info') => {
        const timestamp = new Date().toLocaleTimeString();
        setLogs(prev => [...prev.slice(-50), { timestamp, message, type }]);
      };

      const addNotification = (text, type = 'info') => {
        const id = Date.now();
        setNotifications(prev => [...prev, { id, text, type }]);
        setTimeout(() => dismissNotification(id), 5000);
      };

      const dismissNotification = (id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      };

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      // Initialize user
      useEffect(() => {
        const storedUsername = localStorage.getItem('username');
        if (storedUsername) {
          setUsername(storedUsername);
        } else {
          const randomUsername = `User${Math.floor(Math.random() * 10000)}`;
          setUsername(randomUsername);
          localStorage.setItem('username', randomUsername);
        }
      }, []);

      // Listen for group call updates
      useEffect(() => {
        if (!currentRoom || !username) return;

        const callRef = database.ref(`rooms/${currentRoom}/groupCall`);
        
        const handleCallUpdate = (snapshot) => {
          const callData = snapshot.val();
          if (callData && callData.active) {
            const participants = Object.keys(callData.participants || {});
            setCallParticipants(participants);
            addLog(`Group call participants: ${participants.join(', ')}`);
          } else {
            setCallParticipants([]);
          }
        };

        callRef.on('value', handleCallUpdate);
        return () => callRef.off('value', handleCallUpdate);
      }, [currentRoom, username]);

      // Join room
      const joinRoom = (room) => {
        if (!username) return;
        
        setCurrentRoom(room);
        addLog(`Joining room: ${room}`, 'success');

        const userRef = database.ref(`rooms/${room}/users/${username}`);
        userRef.set({
          username,
          online: true,
          lastSeen: Date.now()
        });

        userRef.onDisconnect().remove();

        const messagesRef = database.ref(`rooms/${room}/messages`);
        messagesRef.on('value', (snapshot) => {
          const msgs = [];
          snapshot.forEach((child) => {
            msgs.push({ id: child.key, ...child.val() });
          });
          setMessages(msgs);
        });

        const usersRef = database.ref(`rooms/${room}/users`);
        usersRef.on('value', (snapshot) => {
          const users = [];
          snapshot.forEach((child) => {
            users.push(child.val());
          });
          setOnlineUsers(users);
        });

        // Listen for call signals
        const signalsRef = database.ref(`rooms/${room}/signals/${username}`);
        signalsRef.on('child_added', handleSignal);
      };

      // Handle WebRTC signals
      const handleSignal = async (snapshot) => {
        const signal = snapshot.val();
        const { from, type, data } = signal;

        addLog(`Received ${type} signal from ${from}`);

        if (type === 'group-call-invite' && !inCall) {
          setIncomingCall({ from, type: 'group' });
        } else if (type === 'offer') {
          await handleOffer(from, data);
        } else if (type === 'answer') {
          await handleAnswer(from, data);
        } else if (type === 'ice-candidate') {
          await handleIceCandidate(from, data);
        }

        snapshot.ref.remove();
      };

      // Start group call
      const startGroupCall = async () => {
        try {
          addLog('Starting group call...', 'info');
          
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
          });
          
          setLocalStream(stream);
          setInCall(true);
          
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }

          // Create/join group call in database
          const callRef = database.ref(`rooms/${currentRoom}/groupCall`);
          await callRef.update({
            active: true,
            [`participants/${username}`]: {
              username,
              muted: false,
              videoOff: false,
              joinedAt: Date.now()
            }
          });

          // Invite all online users
          onlineUsers.forEach(user => {
            if (user.username !== username) {
              sendSignal(user.username, 'group-call-invite', {});
            }
          });

          addLog('Group call started successfully', 'success');
          addNotification('Group call started! Others can now join.');
          
        } catch (err) {
          addLog(`Error starting call: ${err.message}`, 'error');
          addNotification('Failed to start call. Please check camera/mic permissions.', 'error');
        }
      };

      // Join group call
      const joinGroupCall = async () => {
        try {
          addLog('Joining group call...', 'info');
          
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
          });
          
          setLocalStream(stream);
          setInCall(true);
          setIncomingCall(null);
          
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }

          // Add self to group call
          const callRef = database.ref(`rooms/${currentRoom}/groupCall`);
          await callRef.update({
            [`participants/${username}`]: {
              username,
              muted: false,
              videoOff: false,
              joinedAt: Date.now()
            }
          });

          // Create peer connections with existing participants
          const snapshot = await callRef.child('participants').once('value');
          const participants = snapshot.val() || {};
          
          for (const participantName of Object.keys(participants)) {
            if (participantName !== username) {
              await createPeerConnection(participantName, stream, true);
            }
          }

          addLog('Joined group call successfully', 'success');
          addNotification('You joined the group call!');
          
        } catch (err) {
          addLog(`Error joining call: ${err.message}`, 'error');
          addNotification('Failed to join call. Please check camera/mic permissions.', 'error');
        }
      };

      // Create peer connection
      const createPeerConnection = async (peerUsername, stream, isInitiator = false) => {
        try {
          addLog(`Creating peer connection with ${peerUsername} (initiator: ${isInitiator})`);
          
          const configuration = {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          };

          const pc = new RTCPeerConnection(configuration);

          // Add local stream tracks
          stream.getTracks().forEach(track => {
            pc.addTrack(track, stream);
          });

          // Handle incoming tracks
          pc.ontrack = (event) => {
            addLog(`Received track from ${peerUsername}`);
            setRemoteStreams(prev => ({
              ...prev,
              [peerUsername]: event.streams[0]
            }));
          };

          // Handle ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              sendSignal(peerUsername, 'ice-candidate', event.candidate);
            }
          };

          // Handle connection state changes
          pc.onconnectionstatechange = () => {
            addLog(`Connection with ${peerUsername}: ${pc.connectionState}`);
            if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
              handlePeerDisconnection(peerUsername);
            }
          };

          setPeerConnections(prev => ({
            ...prev,
            [peerUsername]: pc
          }));

          // If initiator, create and send offer
          if (isInitiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            sendSignal(peerUsername, 'offer', offer);
          }

          return pc;
        } catch (err) {
          addLog(`Error creating peer connection: ${err.message}`, 'error');
        }
      };

      // Handle offer
      const handleOffer = async (from, offer) => {
        try {
          if (!localStream) return;
          
          let pc = peerConnections[from];
          if (!pc) {
            pc = await createPeerConnection(from, localStream, false);
          }

          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal(from, 'answer', answer);
        } catch (err) {
          addLog(`Error handling offer: ${err.message}`, 'error');
        }
      };

      // Handle answer
      const handleAnswer = async (from, answer) => {
        try {
          const pc = peerConnections[from];
          if (pc) {
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
          }
        } catch (err) {
          addLog(`Error handling answer: ${err.message}`, 'error');
        }
      };

      // Handle ICE candidate
      const handleIceCandidate = async (from, candidate) => {
        try {
          const pc = peerConnections[from];
          if (pc) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
          }
        } catch (err) {
          addLog(`Error handling ICE candidate: ${err.message}`, 'error');
        }
      };

      // Handle peer disconnection
      const handlePeerDisconnection = (peerUsername) => {
        addLog(`${peerUsername} disconnected from call`);
        
        setRemoteStreams(prev => {
          const updated = { ...prev };
          delete updated[peerUsername];
          return updated;
        });

        setPeerConnections(prev => {
          const updated = { ...prev };
          if (updated[peerUsername]) {
            updated[peerUsername].close();
            delete updated[peerUsername];
          }
          return updated;
        });
      };

      // Send signal
      const sendSignal = (to, type, data) => {
        const signalRef = database.ref(`rooms/${currentRoom}/signals/${to}`).push();
        signalRef.set({
          from: username,
          to,
          type,
          data,
          timestamp: Date.now()
        });
      };

      // End call
      const endCall = () => {
        addLog('Ending call...', 'info');

        // Stop local stream
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          setLocalStream(null);
        }

        // Close all peer connections
        Object.values(peerConnections).forEach(pc => pc.close());
        setPeerConnections({});
        setRemoteStreams({});

        // Remove from group call
        if (currentRoom) {
          database.ref(`rooms/${currentRoom}/groupCall/participants/${username}`).remove();
        }

        setInCall(false);
        addNotification('You left the call');
      };

      // Decline call
      const declineCall = () => {
        setIncomingCall(null);
        addNotification('Call declined');
      };

      // Toggle mute
      const toggleMute = () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            setIsMuted(!audioTrack.enabled);
            
            // Update status in database
            if (currentRoom) {
              database.ref(`rooms/${currentRoom}/groupCall/participants/${username}/muted`)
                .set(!audioTrack.enabled);
            }
          }
        }
      };

      // Toggle video
      const toggleVideo = () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            videoTrack.enabled = !videoTrack.enabled;
            setIsVideoOff(!videoTrack.enabled);
            
            // Update status in database
            if (currentRoom) {
              database.ref(`rooms/${currentRoom}/groupCall/participants/${username}/videoOff`)
                .set(!videoTrack.enabled);
            }
          }
        }
      };

      // Send message
      const sendMessage = () => {
        if (newMessage.trim() && currentRoom) {
          const messageRef = database.ref(`rooms/${currentRoom}/messages`).push();
          messageRef.set({
            text: newMessage,
            sender: username,
            timestamp: Date.now(),
            reactions: {}
          });
          setNewMessage('');
        }
      };

      // Snap camera functions
      const openSnapCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: isFrontCamera ? 'user' : 'environment' },
            audio: false
          });
          
          if (snapVideoRef.current) {
            snapVideoRef.current.srcObject = stream;
          }
          
          setShowSnapCamera(true);
        } catch (err) {
          addNotification('Failed to access camera', 'error');
        }
      };

      const closeSnapCamera = () => {
        if (snapVideoRef.current && snapVideoRef.current.srcObject) {
          snapVideoRef.current.srcObject.getTracks().forEach(track => track.stop());
        }
        setShowSnapCamera(false);
        setCapturedSnap(null);
        setRecordedVideo(null);
        setIsRecording(false);
        setRecordingTime(0);
      };

      const flipCamera = async () => {
        const stream = snapVideoRef.current?.srcObject;
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
        
        const newFacingMode = !isFrontCamera;
        setIsFrontCamera(newFacingMode);
        
        try {
          const newStream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: newFacingMode ? 'user' : 'environment' },
            audio: false
          });
          
          if (snapVideoRef.current) {
            snapVideoRef.current.srcObject = newStream;
          }
        } catch (err) {
          addNotification('Failed to flip camera', 'error');
        }
      };

      const captureSnap = () => {
        const video = snapVideoRef.current;
        const canvas = snapCanvasRef.current;
        
        if (video && canvas) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          
          if (isFrontCamera) {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
          }
          
          ctx.drawImage(video, 0, 0);
          const imageData = canvas.toDataURL('image/jpeg', 0.8);
          setCapturedSnap(imageData);
        }
      };

      const toggleCaptureMode = () => {
        setCaptureMode(prev => prev === 'photo' ? 'video' : 'photo');
      };

      const startRecording = async () => {
        const stream = snapVideoRef.current?.srcObject;
        if (!stream) return;

        recordedChunksRef.current = [];
        const mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunksRef.current.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunksRef.current, { type: 'video/webm' });
          const videoUrl = URL.createObjectURL(blob);
          setRecordedVideo(videoUrl);
        };

        mediaRecorderRef.current = mediaRecorder;
        mediaRecorder.start();
        setIsRecording(true);
        setRecordingTime(0);

        recordingIntervalRef.current = setInterval(() => {
          setRecordingTime(prev => prev + 1);
        }, 1000);
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          mediaRecorderRef.current.stop();
          setIsRecording(false);
          clearInterval(recordingIntervalRef.current);
        }
      };

      const retakeSnap = () => {
        setCapturedSnap(null);
        setRecordedVideo(null);
      };

      const sendSnap = () => {
        if (currentRoom && (capturedSnap || recordedVideo)) {
          const messageRef = database.ref(`rooms/${currentRoom}/messages`).push();
          messageRef.set({
            type: capturedSnap ? 'snap' : 'video',
            data: capturedSnap || recordedVideo,
            sender: username,
            timestamp: Date.now(),
            reactions: {}
          });
          closeSnapCamera();
          addNotification(capturedSnap ? 'Snap sent!' : 'Video sent!');
        }
      };

      // Render participant videos
      useEffect(() => {
        Object.entries(remoteStreams).forEach(([peerUsername, stream]) => {
          const videoElement = remoteVideoRefs.current[peerUsername];
          if (videoElement && videoElement.srcObject !== stream) {
            videoElement.srcObject = stream;
          }
        });
      }, [remoteStreams]);

      // Render
      if (!username) {
        return <div style={{ padding: '20px' }}>Loading...</div>;
      }

      if (!currentRoom) {
        return (
          <div style={{ 
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '20px'
          }}>
            <h1 className="glow-text" style={{ fontSize: '48px', marginBottom: '20px' }}>
              Anonymous Chatrooms
            </h1>
            <p style={{ fontSize: '18px', color: '#999', marginBottom: '40px' }}>
              Welcome, {username}
            </p>
            <div style={{ display: 'flex', gap: '15px', flexWrap: 'wrap', justifyContent: 'center' }}>
              {['General', 'Gaming', 'Music', 'Tech', 'Random'].map(room => (
                <button
                  key={room}
                  onClick={() => joinRoom(room)}
                  className="glow-button"
                  style={{
                    padding: '15px 30px',
                    fontSize: '18px',
                    background: '#222',
                    color: '#fff',
                    border: '2px solid #444',
                    borderRadius: '10px',
                    cursor: 'pointer'
                  }}
                >
                  {room}
                </button>
              ))}
            </div>
          </div>
        );
      }

      return (
        <>
          <div style={{ 
            height: '100vh',
            display: 'flex',
            flexDirection: 'column',
            background: '#000'
          }}>
            {/* Header */}
            <div style={{
              padding: '15px 20px',
              background: '#111',
              borderBottom: '1px solid #333',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center'
            }}>
              <div>
                <h2 style={{ fontSize: '20px' }}>#{currentRoom}</h2>
                <p style={{ fontSize: '12px', color: '#666' }}>
                  {onlineUsers.length} online
                  {callParticipants.length > 0 && (
                    <span style={{ marginLeft: '10px', color: '#00ff00' }}>
                      ‚Ä¢ {callParticipants.length} in call
                    </span>
                  )}
                </p>
              </div>
              <div style={{ display: 'flex', gap: '10px' }}>
                {!inCall && callParticipants.length === 0 && (
                  <button
                    onClick={startGroupCall}
                    className="glow-button"
                    style={{
                      padding: '10px 20px',
                      background: '#00ff00',
                      color: '#000',
                      border: 'none',
                      borderRadius: '8px',
                      fontWeight: 'bold',
                      cursor: 'pointer'
                    }}
                  >
                    üìû Start Group Call
                  </button>
                )}
                {!inCall && callParticipants.length > 0 && (
                  <button
                    onClick={joinGroupCall}
                    className="glow-button"
                    style={{
                      padding: '10px 20px',
                      background: '#4CAF50',
                      color: '#fff',
                      border: 'none',
                      borderRadius: '8px',
                      fontWeight: 'bold',
                      cursor: 'pointer'
                    }}
                  >
                    üìû Join Call ({callParticipants.length})
                  </button>
                )}
                <button
                  onClick={() => {
                    setCurrentRoom(null);
                    setMessages([]);
                    if (inCall) endCall();
                  }}
                  style={{
                    padding: '10px 20px',
                    background: '#222',
                    color: '#fff',
                    border: '1px solid #444',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Leave Room
                </button>
              </div>
            </div>

            {/* Messages */}
            {!inCall && (
              <div style={{ 
                flex: 1,
                overflowY: 'auto',
                padding: '20px'
              }}>
                {messages.map(msg => (
                  <div key={msg.id} style={{ marginBottom: '15px' }}>
                    {msg.type === 'snap' || msg.type === 'video' ? (
                      <div>
                        <p style={{ fontSize: '12px', color: '#666', marginBottom: '5px' }}>
                          {msg.sender}
                        </p>
                        {msg.type === 'snap' ? (
                          <img src={msg.data} style={{ maxWidth: '300px', borderRadius: '10px' }} alt="Snap" />
                        ) : (
                          <video src={msg.data} controls style={{ maxWidth: '300px', borderRadius: '10px' }} />
                        )}
                      </div>
                    ) : (
                      <div className="message-bubble" style={{
                        background: msg.sender === username ? '#0084ff' : '#333',
                        color: '#fff',
                        padding: '10px 15px',
                        borderRadius: '18px',
                        maxWidth: '70%',
                        marginLeft: msg.sender === username ? 'auto' : '0'
                      }}>
                        {msg.sender !== username && (
                          <div style={{ fontSize: '12px', opacity: 0.7, marginBottom: '4px' }}>
                            {msg.sender}
                          </div>
                        )}
                        <div>{msg.text}</div>
                      </div>
                    )}
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>
            )}

            {/* Group Call View */}
            {inCall && (
              <div style={{
                flex: 1,
                background: '#000',
                position: 'relative'
              }}>
                <div className={`group-call-grid participants-${Object.keys(remoteStreams).length + 1}`}>
                  {/* Local video */}
                  <div className="participant-video-container">
                    <video
                      ref={localVideoRef}
                      autoPlay
                      playsInline
                      muted
                      className="participant-video"
                      style={{ transform: 'scaleX(-1)' }}
                    />
                    <div className="participant-info">
                      <span>{username} (You)</span>
                      <div className="participant-status">
                        {isMuted && <span className="status-icon">üîá</span>}
                        {isVideoOff && <span className="status-icon">üìπ</span>}
                      </div>
                    </div>
                  </div>

                  {/* Remote videos */}
                  {Object.entries(remoteStreams).map(([peerUsername, stream]) => (
                    <div key={peerUsername} className="participant-video-container">
                      <video
                        ref={el => remoteVideoRefs.current[peerUsername] = el}
                        autoPlay
                        playsInline
                        className="participant-video"
                      />
                      <div className="participant-info">
                        <span>{peerUsername}</span>
                      </div>
                    </div>
                  ))}
                </div>

                {/* Call controls */}
                <div style={{
                  position: 'absolute',
                  bottom: '20px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  display: 'flex',
                  gap: '15px',
                  background: 'rgba(0, 0, 0, 0.8)',
                  padding: '15px 25px',
                  borderRadius: '50px',
                  backdropFilter: 'blur(10px)'
                }}>
                  <button
                    onClick={toggleMute}
                    style={{
                      width: '50px',
                      height: '50px',
                      borderRadius: '50%',
                      background: isMuted ? '#ff3b30' : 'rgba(255, 255, 255, 0.2)',
                      border: 'none',
                      fontSize: '24px',
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                    }}
                    title={isMuted ? 'Unmute' : 'Mute'}
                  >
                    {isMuted ? 'üîá' : 'üé§'}
                  </button>
                  <button
                    onClick={toggleVideo}
                    style={{
                      width: '50px',
                      height: '50px',
                      borderRadius: '50%',
                      background: isVideoOff ? '#ff3b30' : 'rgba(255, 255, 255, 0.2)',
                      border: 'none',
                      fontSize: '24px',
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                    }}
                    title={isVideoOff ? 'Turn on camera' : 'Turn off camera'}
                  >
                    {isVideoOff ? 'üìπ' : 'üì∑'}
                  </button>
                  <button
                    onClick={endCall}
                    style={{
                      width: '50px',
                      height: '50px',
                      borderRadius: '50%',
                      background: '#ff3b30',
                      border: 'none',
                      fontSize: '24px',
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                    }}
                    title="End call"
                  >
                    ‚òéÔ∏è
                  </button>
                </div>

                {/* Notifications in call */}
                {notifications.length > 0 && (
                  <div style={{
                    position: 'absolute',
                    top: '20px',
                    right: '20px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '10px',
                    maxWidth: '300px'
                  }}>
                    {notifications.map(notif => (
                      <div
                        key={notif.id}
                        style={{
                          background: 'rgba(0, 0, 0, 0.9)',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          borderRadius: '10px',
                          padding: '12px',
                          backdropFilter: 'blur(10px)'
                        }}
                      >
                        <div style={{ marginBottom: '8px' }}>{notif.text}</div>
                        <button
                          onClick={() => dismissNotification(notif.id)}
                          style={{
                            background: 'rgba(255, 255, 255, 0.2)',
                            border: '1px solid rgba(255, 255, 255, 0.3)',
                            color: '#fff',
                            padding: '6px 12px',
                            borderRadius: '8px',
                            fontSize: '12px',
                            cursor: 'pointer',
                            width: '100%'
                          }}
                        >
                          Dismiss
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* Message input */}
            {!inCall && (
              <div style={{
                padding: '15px 20px',
                background: '#111',
                borderTop: '1px solid #333',
                display: 'flex',
                gap: '10px'
              }}>
                <button
                  onClick={openSnapCamera}
                  style={{
                    padding: '10px 20px',
                    background: '#ffeb3b',
                    color: '#000',
                    border: 'none',
                    borderRadius: '8px',
                    fontWeight: 'bold',
                    cursor: 'pointer',
                    fontSize: '18px'
                  }}
                >
                  üì∏
                </button>
                <input
                  type="text"
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                  placeholder="Type a message..."
                  style={{
                    flex: 1,
                    padding: '12px 20px',
                    background: '#222',
                    border: '1px solid #444',
                    borderRadius: '25px',
                    color: '#fff',
                    fontSize: '16px'
                  }}
                />
                <button
                  onClick={sendMessage}
                  className="glow-button"
                  style={{
                    padding: '10px 30px',
                    background: '#0084ff',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '25px',
                    fontWeight: 'bold',
                    cursor: 'pointer'
                  }}
                >
                  Send
                </button>
              </div>
            )}

            {/* Incoming Call Modal */}
            {incomingCall && !inCall && (
              <div style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.9)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                zIndex: 10001
              }}>
                <div style={{
                  background: '#111',
                  padding: '40px',
                  borderRadius: '20px',
                  textAlign: 'center',
                  border: '2px solid #333'
                }}>
                  <div style={{ fontSize: '64px', marginBottom: '20px' }} className="glow">üìû</div>
                  <h2 style={{ fontSize: '24px', marginBottom: '10px' }}>Incoming Group Call</h2>
                  <p style={{ fontSize: '18px', color: '#999', marginBottom: '30px' }}>
                    {callParticipants.length} {callParticipants.length === 1 ? 'person' : 'people'} in the call
                  </p>
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button
                      onClick={joinGroupCall}
                      className="glow-button"
                      style={{
                        padding: '15px 40px',
                        background: '#00ff00',
                        color: '#000',
                        border: 'none',
                        borderRadius: '50px',
                        fontSize: '18px',
                        fontWeight: 'bold',
                        cursor: 'pointer'
                      }}
                    >
                      üìû Join
                    </button>
                    <button
                      onClick={declineCall}
                      style={{
                        padding: '15px 40px',
                        background: '#ff3b30',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '50px',
                        fontSize: '18px',
                        fontWeight: 'bold',
                        cursor: 'pointer'
                      }}
                    >
                      ‚ùå Decline
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Snap Camera Modal */}
            {showSnapCamera && (
              <div className="snap-camera-modal">
                <button onClick={closeSnapCamera} className="snap-close-btn">‚úï</button>
                
                <button 
                  onClick={toggleCaptureMode}
                  style={{
                    position: 'absolute',
                    top: '20px',
                    right: '20px',
                    padding: '10px 20px',
                    borderRadius: '50px',
                    background: captureMode === 'photo' ? '#ffeb3b' : '#ff4444',
                    color: '#000',
                    border: 'none',
                    fontSize: '14px',
                    fontWeight: 'bold',
                    cursor: 'pointer',
                    zIndex: 11
                  }}
                >
                  {captureMode === 'photo' ? 'üì∏ Photo' : 'üé• Video'}
                </button>
                
                <div className="snap-video-container">
                  {!capturedSnap && !recordedVideo ? (
                    <>
                      <video 
                        ref={snapVideoRef}
                        autoPlay
                        playsInline
                        muted
                        className="snap-video"
                        style={{ transform: isFrontCamera ? 'scaleX(-1)' : 'none' }}
                      />
                      
                      {isRecording && (
                        <div style={{
                          position: 'absolute',
                          top: '80px',
                          left: '50%',
                          transform: 'translateX(-50%)',
                          background: 'rgba(255, 0, 0, 0.9)',
                          color: '#fff',
                          padding: '10px 20px',
                          borderRadius: '50px',
                          fontSize: '16px',
                          fontWeight: 'bold',
                          zIndex: 11
                        }}>
                          üî¥ {Math.floor(recordingTime / 60)}:{(recordingTime % 60).toString().padStart(2, '0')}
                        </div>
                      )}
                      
                      <div className="snap-controls">
                        <button onClick={flipCamera} className="snap-action-btn">üîÑ</button>
                        
                        {captureMode === 'photo' ? (
                          <button onClick={captureSnap} className="snap-capture-btn" />
                        ) : (
                          <button 
                            onClick={isRecording ? stopRecording : startRecording}
                            className="snap-capture-btn"
                            style={{
                              background: isRecording ? '#ff4444' : '#fff',
                              border: isRecording ? '5px solid #fff' : '5px solid rgba(255, 255, 255, 0.3)'
                            }}
                          />
                        )}
                      </div>
                    </>
                  ) : (
                    <>
                      {capturedSnap && <img src={capturedSnap} className="snap-preview-image" alt="Snap" />}
                      {recordedVideo && <video src={recordedVideo} className="snap-preview-image" controls autoPlay loop />}
                      <div className="snap-controls">
                        <button onClick={retakeSnap} className="snap-action-btn">‚Ü∫</button>
                      </div>
                      <button onClick={sendSnap} className="snap-send-btn">
                        üì§ Send {capturedSnap ? 'Snap' : 'Video'}
                      </button>
                    </>
                  )}
                  <canvas ref={snapCanvasRef} style={{ display: 'none' }} />
                </div>
              </div>
            )}

            {!showDebug && (
              <div 
                onClick={() => setShowDebug(true)}
                style={{
                  position: 'fixed',
                  bottom: '20px',
                  left: '20px',
                  width: '40px',
                  height: '40px',
                  background: '#222',
                  border: '1px solid #444',
                  borderRadius: '50%',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  cursor: 'pointer',
                  zIndex: 9999
                }}
              >
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </div>
        </>
      );
    }

    ReactDOM.render(<ChatroomApp />, document.getElementById('root'));
  </script>
</body>
</html>
