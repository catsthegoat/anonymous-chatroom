<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonymous Chatrooms</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
    }

    /* ‚îÄ‚îÄ Proxy Browser ‚îÄ‚îÄ */
    .proxy-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 99999;
      display: flex;
      flex-direction: column;
    }
    .proxy-bar {
      display: flex;
      gap: 8px;
      padding: 10px 14px;
      background: #111;
      border-bottom: 1px solid #222;
      flex-shrink: 0;
    }
    .proxy-bar input {
      flex: 1;
      padding: 9px 14px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      outline: none;
    }
    .proxy-bar input:focus { border-color: #555; }
    .proxy-bar button {
      padding: 9px 18px;
      border-radius: 8px;
      border: none;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
    }
    .proxy-go { background: #fff; color: #000; }
    .proxy-go:hover { background: #ddd; }
    .proxy-close { background: #1a1a1a; color: #fff; border: 1px solid #333 !important; }
    .proxy-close:hover { background: #2a2a2a; }
    .proxy-iframe {
      flex: 1;
      border: none;
      width: 100%;
      background: #000;
    }
    .proxy-placeholder {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #444;
      font-size: 15px;
    }
    .proxy-fab {
      position: fixed;
      bottom: 80px;
      right: 20px;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: #fff;
      color: #000;
      border: none;
      font-size: 22px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s;
    }
    .proxy-fab:hover { transform: scale(1.1); }

    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5)); }
      50% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.8)); }
    }

    @keyframes slideIn {
      from {
        transform: translateX(-100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .glow {
      animation: glow 2s ease-in-out infinite;
    }

    .glow-text {
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.4);
    }

    .glow-border {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.1);
    }

    .glow-button {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
    }

    .glow-button:hover {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
      background: #fff !important;
      color: #000 !important;
    }

    input:focus, textarea:focus {
      outline: none;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .message-bubble {
      transition: all 0.3s ease;
      position: relative;
    }

    .message-bubble:hover {
      transform: translateY(-2px);
    }

    .message-bubble:hover .message-actions {
      opacity: 1;
      pointer-events: auto;
    }

    .message-actions {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      position: absolute;
      top: -5px;
      right: 5px;
      display: flex;
      gap: 5px;
      z-index: 10;
    }

    .action-btn {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      font-size: 14px;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }

    .action-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      transform: scale(1.1);
    }

    .emoji-picker {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 5px;
      margin-bottom: 5px;
      box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .emoji-btn {
      background: transparent;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.2s;
    }

    .emoji-btn:hover {
      background: #2a2a2a;
      transform: scale(1.2);
    }

    .reaction-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 8px;
    }

    .reaction {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 4px 10px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .reaction:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .reaction.active {
      background: rgba(255, 255, 255, 0.3);
      border-color: #fff;
      font-weight: bold;
    }

    .typing-indicator {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 10px 15px;
      margin-bottom: 10px;
      font-size: 13px;
      color: #999;
      font-style: italic;
    }

    .system-message {
      text-align: center;
      color: #666;
      font-size: 13px;
      font-style: italic;
      padding: 8px;
      margin: 10px 0;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }

    .snap-camera-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 10002;
      display: flex;
      flex-direction: column;
    }

    .snap-video-container {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .snap-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .snap-preview-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .snap-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      align-items: center;
      z-index: 10;
    }

    .snap-capture-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: #fff;
      border: 5px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 15px rgba(255, 255, 255, 0.4);
    }

    .snap-capture-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.6);
    }

    .snap-capture-btn:active {
      transform: scale(0.95);
    }

    .snap-action-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #fff;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
    }

    .snap-action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .snap-close-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid #fff;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      backdrop-filter: blur(10px);
      z-index: 11;
    }

    .snap-close-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .snap-send-btn {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 15px 30px;
      border-radius: 50px;
      background: #fff;
      color: #000;
      border: none;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 15px rgba(255, 255, 255, 0.4);
      transition: all 0.2s;
      z-index: 11;
    }

    .snap-send-btn:hover {
      background: #ffeb3b;
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.6);
    }

    .video-call-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 10000;
      display: flex;
      flex-direction: column;
    }

    .video-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 20px;
    }

    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }
    .remote-video {
      width: 80%;
      max-width: 800px;
      height: auto;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 20px;
      background: #000;
    }

    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }
    .local-video {
      position: absolute;
      bottom: 140px;
      right: 20px;
      width: 150px;
      height: 120px;
      object-fit: cover;
      border-radius: 15px;
      border: 3px solid #fff;
      box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
    }

    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }
    .call-controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      padding: 15px 25px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      z-index: 100;
    }

    .call-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 24px;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .call-btn:hover {
      transform: scale(1.1);
    }

    .call-btn.end {
      background: #ff3b30;
      color: #fff;
    }

    .call-btn.mute {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .call-btn.video-toggle {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .incoming-call {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a1a;
      padding: 40px;
      border-radius: 20px;
      border: 2px solid #fff;
      text-align: center;
      z-index: 10001;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
    }

    .call-status {
      text-align: center;
      font-size: 18px;
      color: #fff;
      margin-bottom: 20px;
    }

    .reply-preview {
      background: rgba(255, 255, 255, 0.05);
      border-left: 3px solid #666;
      padding: 10px 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      font-size: 13px;
    }

    .reply-to {
      background: rgba(255, 255, 255, 0.05);
      border-left: 3px solid currentColor;
      padding: 6px 10px;
      margin-bottom: 8px;
      border-radius: 3px;
      font-size: 12px;
      opacity: 0.8;
    }

    .debug-console {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      max-width: 400px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      z-index: 999;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .debug-log {
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 6px;
      border-left: 3px solid;
    }

    .debug-log.info { border-color: #4a9eff; background: rgba(74, 158, 255, 0.1); }
    .debug-log.success { border-color: #00ff00; background: rgba(0, 255, 0, 0.1); }
    .debug-log.error { border-color: #ff0000; background: rgba(255, 0, 0, 0.1); }
    .debug-log.warning { border-color: #ffaa00; background: rgba(255, 170, 0, 0.1); }

    .debug-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #333;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 998;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .debug-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
    }

    /* Minimized window styles */
    .minimized-window {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      z-index: 900;
      transition: all 0.3s ease;
    }

    .minimized-window.maximized {
      width: 90vw;
      height: 90vh;
      bottom: 5vh;
      right: 5vw;
      z-index: 950;
    }

    .minimized-window-header {
      background: #1a1a1a;
      padding: 10px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: move;
      border-bottom: 1px solid #333;
    }

    .minimized-window-title {
      font-size: 14px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .minimized-window-controls {
      display: flex;
      gap: 8px;
    }

    .window-btn {
      background: transparent;
      border: none;
      color: #999;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s;
      font-size: 16px;
      line-height: 1;
    }

    .window-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .minimized-window-content {
      height: 200px;
      overflow: hidden;
    }

    .minimized-window.maximized .minimized-window-content {
      height: calc(90vh - 50px);
    }

    .game-iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const firebaseConfig = {
      apiKey: "AIzaSyCR9UiBA6mg3J5a6WGtPK9F76E_ul1D1_c",
      authDomain: "chatroom-60410.firebaseapp.com",
      databaseURL: "https://chatroom-60410-default-rtdb.firebaseio.com",
      projectId: "chatroom-60410",
      storageBucket: "chatroom-60410.firebasestorage.app",
      messagingSenderId: "1074130659134",
      appId: "1:1074130659134:web:06b77a69a0c1d2ee47ee6f",
      measurementId: "G-ENN9HEXNDB"
    };

    let db = null;
    const debugLogs = [];
    
    const addDebugLogGlobal = (message, type = 'info') => {
      const timestamp = new Date().toLocaleTimeString();
      debugLogs.push({ message, type, timestamp });
      if (debugLogs.length > 50) debugLogs.shift();
      console.log(`[${type.toUpperCase()}] ${message}`);
    };

    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
        addDebugLogGlobal('Firebase initialized', 'success');
      }
      db = firebase.database();
      addDebugLogGlobal('Database connection established', 'success');
    } catch (error) {
      addDebugLogGlobal(`Firebase error: ${error.message}`, 'error');
    }

    const EMOJIS = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üò°', 'üéâ', 'üî•', 'üëÄ', 'üíØ', 'üôè', '‚ú®'];

    const MessageCircle = () => <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>;
    const Send = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>;
    const LogOut = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>;
    const Plus = () => <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
    const Trash = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>;
    const Users = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>;
    const UserX = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="8.5" cy="7" r="4"/><line x1="18" y1="8" x2="23" y2="13"/><line x1="23" y1="8" x2="18" y2="13"/></svg>;
    const Gamepad = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><line x1="15" y1="13" x2="15.01" y2="13"/><line x1="18" y1="11" x2="18.01" y2="11"/><rect x="2" y="6" width="20" height="12" rx="2"/></svg>;
    const Bug = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="8" y="6" width="8" height="14" rx="4"/><path d="M6 12h4m8 0h4M8 6V4a2 2 0 0 1 4 0v2m4 0V4a2 2 0 0 1 4 0v2M8 18v2a2 2 0 0 0 4 0v-2m4 0v2a2 2 0 0 0 4 0v-2"/></svg>;
    const Smile = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>;

    // Minimized Window Component
    const MinimizedWindow = ({ title, url, onClose, icon }) => {
      const [isMaximized, setIsMaximized] = useState(false);
      const [position, setPosition] = useState({ x: window.innerWidth - 320, y: window.innerHeight - 250 });
      const [isDragging, setIsDragging] = useState(false);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

      const handleMouseDown = (e) => {
        if (e.target.closest('.window-btn')) return;
        setIsDragging(true);
        setDragOffset({
          x: e.clientX - position.x,
          y: e.clientY - position.y
        });
      };

      const handleMouseMove = (e) => {
        if (isDragging && !isMaximized) {
          setPosition({
            x: e.clientX - dragOffset.x,
            y: e.clientY - dragOffset.y
          });
        }
      };

      const handleMouseUp = () => {
        setIsDragging(false);
      };

      useEffect(() => {
        if (isDragging) {
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
          };
        }
      }, [isDragging, dragOffset]);

      return (
        <div 
          className={`minimized-window ${isMaximized ? 'maximized' : ''}`}
          style={!isMaximized ? { 
            left: `${position.x}px`, 
            top: `${position.y}px`,
            right: 'auto',
            bottom: 'auto'
          } : {}}
        >
          <div 
            className="minimized-window-header"
            onMouseDown={handleMouseDown}
          >
            <div className="minimized-window-title">
              <span>{icon}</span>
              <span>{title}</span>
            </div>
            <div className="minimized-window-controls">
              <button 
                className="window-btn" 
                onClick={() => setIsMaximized(!isMaximized)}
                title={isMaximized ? "Minimize" : "Maximize"}
              >
                {isMaximized ? 'üóó' : 'üóñ'}
              </button>
              <button 
                className="window-btn" 
                onClick={onClose}
                title="Close"
              >
                ‚úï
              </button>
            </div>
          </div>
          <div className="minimized-window-content">
            <iframe 
              src={url} 
              className="game-iframe"
              title={title}
              allow="camera; microphone; fullscreen"
            />
          </div>
        </div>
      );
    };

    const DebugConsole = ({ logs, onClose }) => (
      <div className="debug-console">
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px', borderBottom: '1px solid #333', paddingBottom: '10px' }}>
          <strong>üêõ Debug Console</strong>
          <button onClick={onClose} style={{ background: 'transparent', border: 'none', color: '#999', cursor: 'pointer', fontSize: '18px' }}>√ó</button>
        </div>
        <div style={{ marginBottom: '10px', padding: '10px', background: '#1a1a1a', borderRadius: '8px', fontSize: '12px' }}>
          <strong style={{ color: '#4CAF50' }}>üìã Browser Console Instructions:</strong>
          <div style={{ marginTop: '5px', color: '#999' }}>
            Press <strong style={{ color: '#fff' }}>F12</strong> or <strong style={{ color: '#fff' }}>Ctrl+Shift+I</strong> (Windows) / <strong style={{ color: '#fff' }}>Cmd+Option+I</strong> (Mac)
          </div>
          <div style={{ color: '#999' }}>
            Click the <strong style={{ color: '#fff' }}>"Console"</strong> tab to see detailed camera & snap debugging
          </div>
        </div>
        <div>
          {logs.slice(-20).map((log, i) => (
            <div key={i} className={`debug-log ${log.type}`}>
              <div style={{ fontSize: '10px', color: '#666', marginBottom: '2px' }}>{new Date(log.timestamp).toLocaleTimeString()}</div>
              <div>{log.message}</div>
            </div>
          ))}
        </div>
      </div>
    );

    function ChatroomApp() {
      const [username, setUsername] = useState('');
      const [tempUsername, setTempUsername] = useState('');
      const [currentView, setCurrentView] = useState('start');
      const [currentRoom, setCurrentRoom] = useState(null);
      const [rooms, setRooms] = useState([]);
      const [messages, setMessages] = useState([]);
      const [message, setMessage] = useState('');
      const [newRoomName, setNewRoomName] = useState('');
      const [newRoomPassword, setNewRoomPassword] = useState('');
      const [error, setError] = useState('');
      const [roomUsers, setRoomUsers] = useState([]);
      const [typingUsers, setTypingUsers] = useState([]);
      const [replyTo, setReplyTo] = useState(null);
      const [showEmojiPicker, setShowEmojiPicker] = useState(null);
      const [logs, setLogs] = useState([]);
      const [showDebug, setShowDebug] = useState(false);
      const [showImageInput, setShowImageInput] = useState(false);
      const [imageUrl, setImageUrl] = useState('');
      const [showGamesMenu, setShowGamesMenu] = useState(false);
      const [gameInvite, setGameInvite] = useState(null);
      const [openGameWindows, setOpenGameWindows] = useState([]);
      const [inCall, setInCall] = useState(false);
      const [callWith, setCallWith] = useState(null);
      const [incomingCall, setIncomingCall] = useState(null);
      const [localStream, setLocalStream] = useState(null);
      const [remoteStream, setRemoteStream] = useState(null);
      const [isMuted, setIsMuted] = useState(false);
      const [isVideoOff, setIsVideoOff] = useState(false);
      const [showSnapCamera, setShowSnapCamera] = useState(false);
      const [snapStream, setSnapStream] = useState(null);
      const [capturedSnap, setCapturedSnap] = useState(null);
      const [isFrontCamera, setIsFrontCamera] = useState(true);
      const [isRecording, setIsRecording] = useState(false);
      const [recordedVideo, setRecordedVideo] = useState(null);
      const [mediaRecorder, setMediaRecorder] = useState(null);
      const [recordingTime, setRecordingTime] = useState(0);
      const [captureMode, setCaptureMode] = useState('photo'); // 'photo' or 'video'
      const [inCallNotifications, setInCallNotifications] = useState([]);
      const [isGroupCall, setIsGroupCall] = useState(false);
      const [groupCallParticipants, setGroupCallParticipants] = useState([]);
      const [groupCallActive, setGroupCallActive] = useState(false);

      const messagesEndRef = useRef(null);
      const typingTimeoutRef = useRef(null);
      const localVideoRef = useRef(null);
      const remoteVideoRef = useRef(null);
      const peerConnectionRef = useRef(null);
      const callListenersRef = useRef([]);
      const snapVideoRef = useRef(null);
      const snapCanvasRef = useRef(null);
      const recordingIntervalRef = useRef(null);
      const groupPeerConnectionsRef = useRef({});
      const participantStreamsRef = useRef({});
      const participantVideoRefs = useRef({});
      const groupLocalStreamRef = useRef(null);
      const groupCallListenersRef = useRef([]);

      const addDebugLog = (message, type = 'info') => {
        addDebugLogGlobal(message, type);
      };

      useEffect(() => {
        const interval = setInterval(() => {
          setLogs([...debugLogs]);
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      useEffect(() => {
        if (db) {
          const connectedRef = db.ref('.info/connected');
          connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
              addDebugLog('Firebase connected', 'success');
            } else {
              addDebugLog('Firebase disconnected', 'error');
            }
          });
          return () => connectedRef.off();
        }
      }, []);

      useEffect(() => {
        if (db) {
          const roomsRef = db.ref('rooms');
          const handleRooms = (snapshot) => {
            const data = snapshot.val();
            setRooms(data ? Object.values(data) : []);
            addDebugLog(`Rooms loaded: ${data ? Object.keys(data).length : 0}`, 'info');
          };
          roomsRef.on('value', handleRooms);
          return () => roomsRef.off('value', handleRooms);
        }
      }, []);

      useEffect(() => {
        if (username && currentRoom && db) {
          addDebugLog(`Joined room ${currentRoom}`, 'success');
          const userRef = db.ref(`roomUsers/${currentRoom}/${username}`);
          userRef.set(Date.now());
          userRef.onDisconnect().remove();

          const usersRef = db.ref(`roomUsers/${currentRoom}`);
          const handleUsers = (snapshot) => {
            const data = snapshot.val();
            setRoomUsers(data ? Object.keys(data) : []);
          };
          usersRef.on('value', handleUsers);

          const typingRef = db.ref(`typing/${currentRoom}`);
          const handleTyping = (snapshot) => {
            const data = snapshot.val();
            if (data) {
              const now = Date.now();
              const activeTypers = Object.entries(data)
                .filter(([user, time]) => user !== username && now - time < 3000)
                .map(([user]) => user);
              setTypingUsers(activeTypers);
            } else {
              setTypingUsers([]);
            }
          };
          const typingInterval = setInterval(() => typingRef.once('value', handleTyping), 1000);

          return () => {
            usersRef.off('value', handleUsers);
            clearInterval(typingInterval);
            userRef.remove();
          };
        }
      }, [username, currentRoom]);

      useEffect(() => {
        if (currentRoom && db) {
          const messagesRef = db.ref(`messages/${currentRoom}`);
          const handleMessages = (snapshot) => {
            const data = snapshot.val();
            setMessages(data ? Object.values(data).sort((a, b) => a.timestamp - b.timestamp) : []);
          };
          messagesRef.on('value', handleMessages);
          return () => messagesRef.off('value', handleMessages);
        }
      }, [currentRoom]);

      useEffect(() => {
        if (currentRoom && db) {
          const inviteRef = db.ref(`gameInvites/${currentRoom}`);
          const handleInvite = (snapshot) => {
            const data = snapshot.val();
            setGameInvite(data);
          };
          inviteRef.on('value', handleInvite);
          return () => inviteRef.off('value', handleInvite);
        }
      }, [currentRoom]);

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      // Show notification for new messages during calls
      useEffect(() => {
        if (inCall && messages.length > 0) {
          const lastMessage = messages[messages.length - 1];
          // Only show notification if it's not from the current user and it's a recent message
          if (lastMessage.username !== username && Date.now() - lastMessage.timestamp < 2000) {
            const notifId = Date.now().toString();
            const newNotif = {
              id: notifId,
              from: lastMessage.username,
              text: lastMessage.type === 'snap' ? 'üì∏ Sent a snap' : lastMessage.text,
              timestamp: Date.now()
            };
            
            setInCallNotifications(prev => [...prev, newNotif]);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
              setInCallNotifications(prev => prev.filter(n => n.id !== notifId));
            }, 10000);
          }
        }
      }, [messages, inCall, username]);

      const dismissNotification = (notifId) => {
        setInCallNotifications(prev => prev.filter(n => n.id !== notifId));
      };

      // Attach local stream to the local video element whenever it changes
      useEffect(() => {
        if (localStream && localVideoRef.current && inCall) {
          if (localVideoRef.current.srcObject !== localStream) {
            localVideoRef.current.srcObject = localStream;
            localVideoRef.current.play().catch(() => {});
          }
        }
      }, [localStream, inCall, isGroupCall]);

      useEffect(() => {
        if (username && currentRoom) {
          addDebugLog(`Joined room ${currentRoom}`, 'success');
          const userRef = db.ref(`roomUsers/${currentRoom}/${username}`);
          userRef.set(Date.now());
          userRef.onDisconnect().remove();

          const usersRef = db.ref(`roomUsers/${currentRoom}`);
          const handleUsers = (snapshot) => {
            const data = snapshot.val();
            setRoomUsers(data ? Object.keys(data) : []);
          };
          usersRef.on('value', handleUsers);

          const typingRef = db.ref(`typing/${currentRoom}`);
          const handleTyping = (snapshot) => {
            const data = snapshot.val();
            if (data) {
              const now = Date.now();
              const activeTypers = Object.entries(data)
                .filter(([user, time]) => user !== username && now - time < 3000)
                .map(([user]) => user);
              setTypingUsers(activeTypers);
            } else {
              setTypingUsers([]);
            }
          };
          const typingInterval = setInterval(() => typingRef.once('value', handleTyping), 1000);

          return () => {
            usersRef.off('value', handleUsers);
            clearInterval(typingInterval);
            userRef.remove();
          };
        }
      }, [username, currentRoom]);

      useEffect(() => {
        const roomsRef = db.ref('rooms');
        const handleRooms = (snapshot) => {
          const data = snapshot.val();
          setRooms(data ? Object.values(data) : []);
        };
        roomsRef.on('value', handleRooms);
        return () => roomsRef.off('value', handleRooms);
      }, []);

      // Prevent accidental tab closing when user is active in the chat
      useEffect(() => {
        const handleBeforeUnload = (e) => {
          // Only show warning if user is logged in and in a room
          if (username && currentRoom) {
            e.preventDefault();
            e.returnValue = ''; // Chrome requires returnValue to be set
            return ''; // Some browsers show this message
          }
        };

        window.addEventListener('beforeunload', handleBeforeUnload);
        
        return () => {
          window.removeEventListener('beforeunload', handleBeforeUnload);
        };
      }, [username, currentRoom]);

      const sendImageUrl = async () => {
        console.log('=== IMAGE URL SEND DEBUG ===');
        console.log('Image URL:', imageUrl);
        console.log('Current room:', currentRoom);
        console.log('Username:', username);
        
        if (!imageUrl.trim() || !currentRoom || !username) {
          console.error('Missing required data!');
          return;
        }
        
        let finalImageUrl = imageUrl.trim();
        
        // Convert Giphy page URLs to media URLs
        if (finalImageUrl.includes('giphy.com/gifs/')) {
          console.log('Detected Giphy page URL, converting...');
          // Extract the GIF ID from URLs like: https://giphy.com/gifs/spongebob-boi-breathe-in-Mp4YvyzWMpXCWAD7mX
          const gifIdMatch = finalImageUrl.match(/gifs\/[^\/]+-([A-Za-z0-9]+)$/);
          if (gifIdMatch) {
            const gifId = gifIdMatch[1];
            // Convert to media URL
            finalImageUrl = `https://media.giphy.com/media/${gifId}/giphy.gif`;
            console.log('Converted to media URL:', finalImageUrl);
          }
        }
        
        // Also handle tenor URLs
        if (finalImageUrl.includes('tenor.com/view/')) {
          console.log('Detected Tenor page URL - please use "Copy GIF Link" instead');
          setError('For Tenor, right-click the GIF and select "Copy image address"');
          return;
        }
        
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const newMsg = {
          id: msgId,
          username,
          type: 'snap',
          image: finalImageUrl,
          timestamp: Date.now(),
          reactions: {}
        };
        
        console.log('Message object:', newMsg);
        console.log('Firebase path:', `messages/${currentRoom}/${msgId}`);
        
        try {
          console.log('Sending to Firebase...');
          await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
          console.log('‚úÖ SUCCESS! Image URL sent');
          addDebugLog('Image sent', 'success');
          setImageUrl('');
          setShowImageInput(false);
        } catch (err) {
          console.error('‚ùå FIREBASE ERROR:', err);
          console.error('Error message:', err.message);
          setError('Failed to send image: ' + err.message);
          addDebugLog(`Image send error: ${err.message}`, 'error');
        }
        
        console.log('=== IMAGE URL SEND END ===');
      };

      // Snap Camera Functions
      const openSnapCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: isFrontCamera ? 'user' : 'environment' }, 
            audio: true // Need audio for video recording
          });
          setSnapStream(stream);
          setShowSnapCamera(true);
          setCaptureMode('photo'); // Default to photo mode
          if (snapVideoRef.current) {
            snapVideoRef.current.srcObject = stream;
          }
        } catch (err) {
          console.error('Camera access error:', err);
          setError('Could not access camera');
        }
      };

      const closeSnapCamera = () => {
        if (snapStream) {
          snapStream.getTracks().forEach(track => track.stop());
          setSnapStream(null);
        }
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
        if (recordingIntervalRef.current) {
          clearInterval(recordingIntervalRef.current);
        }
        setShowSnapCamera(false);
        setCapturedSnap(null);
        setRecordedVideo(null);
        setIsRecording(false);
        setRecordingTime(0);
        setMediaRecorder(null);
      };

      const captureSnap = () => {
        if (snapVideoRef.current && snapCanvasRef.current) {
          const video = snapVideoRef.current;
          const canvas = snapCanvasRef.current;
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          const imageData = canvas.toDataURL('image/jpeg', 0.8);
          setCapturedSnap(imageData);
        }
      };

      const startRecording = () => {
        if (!snapStream) return;
        
        const recorder = new MediaRecorder(snapStream, {
          mimeType: 'video/webm;codecs=vp9'
        });
        
        const chunks = [];
        recorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            chunks.push(e.data);
          }
        };
        
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const videoUrl = URL.createObjectURL(blob);
          
          // Convert blob to base64 for Firebase
          const reader = new FileReader();
          reader.onloadend = () => {
            setRecordedVideo(reader.result);
          };
          reader.readAsDataURL(blob);
          
          clearInterval(recordingIntervalRef.current);
        };
        
        recorder.start();
        setMediaRecorder(recorder);
        setIsRecording(true);
        setRecordingTime(0);
        
        // Update recording time every second
        recordingIntervalRef.current = setInterval(() => {
          setRecordingTime(prev => {
            const newTime = prev + 1;
            if (newTime >= 60) { // Max 60 seconds
              stopRecording();
            }
            return newTime;
          });
        }, 1000);
      };

      const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          setIsRecording(false);
        }
      };

      const retakeSnap = () => {
        setCapturedSnap(null);
        setRecordedVideo(null);
      };

      const flipCamera = async () => {
        const newFacingMode = !isFrontCamera;
        setIsFrontCamera(newFacingMode);
        
        if (snapStream) {
          snapStream.getTracks().forEach(track => track.stop());
        }
        
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: newFacingMode ? 'user' : 'environment' }, 
            audio: true
          });
          setSnapStream(stream);
          if (snapVideoRef.current) {
            snapVideoRef.current.srcObject = stream;
          }
        } catch (err) {
          console.error('Camera flip error:', err);
          setError('Could not flip camera');
        }
      };

      const sendSnap = async () => {
        if ((!capturedSnap && !recordedVideo) || !currentRoom || !username) return;
        
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        
        if (capturedSnap) {
          // Send photo
          const newMsg = {
            id: msgId,
            username,
            type: 'snap',
            image: capturedSnap,
            timestamp: Date.now(),
            reactions: {}
          };
          
          try {
            await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
            addDebugLog('Snap sent', 'success');
            closeSnapCamera();
          } catch (err) {
            console.error('Snap send error:', err);
            setError('Failed to send snap');
          }
        } else if (recordedVideo) {
          // Send video
          const newMsg = {
            id: msgId,
            username,
            type: 'video',
            videoUrl: recordedVideo,
            timestamp: Date.now(),
            reactions: {}
          };
          
          try {
            await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
            addDebugLog('Video sent', 'success');
            closeSnapCamera();
          } catch (err) {
            console.error('Video send error:', err);
            setError('Failed to send video');
          }
        }
      };

      const toggleCaptureMode = () => {
        setCaptureMode(prev => prev === 'photo' ? 'video' : 'photo');
      };

      // Video Call Functions
const startCall = async (targetUser) => {
        try {
          console.log('=== START CALL ===');
          console.log('Calling:', targetUser);
          
          // Get local media stream with better constraints
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: 'user',
              frameRate: { ideal: 24, max: 30 }
            }, 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          
          console.log('‚úÖ Got local stream');
          console.log('Video tracks:', stream.getVideoTracks().length);
          console.log('Audio tracks:', stream.getAudioTracks().length);
          
          setInCall(true);
          setCallWith(targetUser);
          
          setLocalStream(stream);
          
          // Wait for React to render the video element, then attach stream
          setTimeout(() => {
            if (localVideoRef.current && stream) {
              console.log('üé• Attaching local stream to video element (caller)');
              localVideoRef.current.srcObject = stream;
              localVideoRef.current.play().catch(err => console.error('Local video play error:', err));
            }
          }, 100);

// Fetch TURN credentials dynamically
          let iceServers = [{ urls: "stun:stun.l.google.com:19302" }]; // fallback
          try {
            const response = await fetch("https://global.xirsys.net/_turn/MyFirstApp", {
              method: "PUT",
              headers: {
                "Authorization": "Basic " + btoa("emmaahef:98b96996-0dd0-11f1-a555-0242ac150006"),
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ format: "urls" })
            });
            if (!response.ok) {
              const errText = await response.text();
              console.error("‚ùå Xirsys error:", response.status, errText);
            } else {
              const data = await response.json();
              console.log("‚úÖ Xirsys response:", data);
              if (data.v && data.v.iceServers) {
                const raw = data.v.iceServers;
                const list = Array.isArray(raw) ? raw : [raw];
                console.log("üìã Raw Xirsys servers:", JSON.stringify(list));
                // Xirsys may return 'url' OR 'urls' depending on format - handle both
                iceServers = list
                  .filter(s => s.url || s.urls)
                  .map(s => {
                    const entry = { urls: s.urls || s.url };
                    if (s.username) entry.username = s.username;
                    if (s.credential) entry.credential = s.credential;
                    return entry;
                  });
                console.log("‚úÖ ICE servers ready:", JSON.stringify(iceServers));
              } else {
                console.error("‚ùå Xirsys bad response:", data);
              }
            }
          } catch (err) {
            console.error("‚ùå Xirsys fetch failed:", err);
          }

          // Create peer connection
          const configuration = {
            iceServers: iceServers,
            iceCandidatePoolSize: 10
          };
          console.log("üîß RTCPeerConnection config:", JSON.stringify(configuration));
        const peerConnection = new RTCPeerConnection(configuration);
          peerConnectionRef.current = peerConnection;
          
          // Monitor connection state ('disconnected' is transient, only end on failed/closed)
peerConnection.onconnectionstatechange = () => {
  const s = peerConnection.connectionState;
  console.log('Connection state:', s);
  if (s === 'failed' || s === 'closed') endCall();
};
peerConnection.oniceconnectionstatechange = () => {
  const s = peerConnection.iceConnectionState;
  console.log('ICE state:', s);
  if (s === 'failed') endCall();
};
          
          peerConnection.oniceconnectionstatechange = () => {
            console.log('üßä ICE state:', peerConnection.iceConnectionState);
          };

          // CRITICAL FIX: Add tracks BEFORE creating offer
          stream.getTracks().forEach(track => {
            peerConnection.addTrack(track, stream);
            console.log('‚úÖ Added track:', track.kind, 'enabled:', track.enabled);
          });

         // Handle incoming tracks - FIXED
// Handle incoming tracks - FIXED
          peerConnection.ontrack = (event) => {
            console.log('üé• RECEIVED REMOTE TRACK:', event.track.kind);
            console.log('Track enabled:', event.track.enabled);
            console.log('Track readyState:', event.track.readyState);
            
            if (event.streams && event.streams[0]) {
              const remoteStream = event.streams[0];
              console.log('Remote stream tracks:', remoteStream.getTracks().length);
              
              setRemoteStream(remoteStream);
              
              // Force immediate attachment
              if (remoteVideoRef.current) {
                remoteVideoRef.current.srcObject = remoteStream;
                console.log('‚úÖ Remote video srcObject set');
                
                // Force play immediately
                remoteVideoRef.current.play()
                  .then(() => console.log('‚úÖ Remote video playing'))
                  .catch(err => {
                    console.error('Play error:', err);
                    // Retry after a short delay
                    setTimeout(() => {
                      remoteVideoRef.current.play().catch(e => console.error('Retry failed:', e));
                    }, 500);
                  });
              }
            }
          };
          
          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log('üì° Sending ICE candidate');
              db.ref(`calls/${currentRoom}/${targetUser}/candidates/${username}`).push({
                candidate: event.candidate.toJSON()
              });
            }
          };

          // Create offer with proper options
          console.log('Creating offer...');
          const offer = await peerConnection.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          });
          await peerConnection.setLocalDescription(offer);
          console.log('‚úÖ Offer created');

          // Send offer to Firebase
          await db.ref(`calls/${currentRoom}/${targetUser}/offer`).set({
            from: username,
            offer: {
              type: offer.type,
              sdp: offer.sdp
            },
            timestamp: Date.now()
          });
          console.log('‚úÖ Offer sent');

          addDebugLog(`Calling ${targetUser}...`, 'info');

          // Listen for answer
          const answerRef = db.ref(`calls/${currentRoom}/${username}/answer`);
          answerRef.on('value', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.from === targetUser && peerConnectionRef.current) {
              console.log('‚úÖ Answer received');
              const answer = new RTCSessionDescription(data.answer);
              await peerConnectionRef.current.setRemoteDescription(answer);
            }
          });

          // Listen for ICE candidates from remote peer
          const candidatesRef = db.ref(`calls/${currentRoom}/${username}/candidates/${targetUser}`);
          candidatesRef.on('child_added', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.candidate && peerConnectionRef.current) {
              try {
                await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('‚úÖ Added ICE candidate');
              } catch (err) {
                console.error('ICE error:', err);
              }
            }
          });

          // CRITICAL FIX: Listen for hang-up
          const hangupRef = db.ref(`calls/${currentRoom}/${username}/hangup`);
          hangupRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.from === targetUser) {
              console.log('üìû Remote peer hung up');
              endCall();
              alert(`${targetUser} ended the call`);
            }
          });

          // Listen for decline
          const declineRef = db.ref(`calls/${currentRoom}/${username}/declined`);
          declineRef.on('value', (snapshot) => {
            if (snapshot.val() === true) {
              console.log('üìû Call declined');
              endCall();
              alert(`${targetUser} declined your call`);
              db.ref(`calls/${currentRoom}/${username}`).remove();
            }
          });

        } catch (err) {
          console.error('CALL ERROR:', err);
          setError('Failed to start call: ' + err.message);
          setInCall(false);
          setCallWith(null);
          addDebugLog(`Call error: ${err.message}`, 'error');
        }
      };

 const answerCall = async (caller) => {
        try {
          console.log('üìû Answering call from:', caller);
          
          // Get local media stream
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: 'user',
              frameRate: { ideal: 24, max: 30 }
            }, 
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          
          console.log('‚úÖ Got local stream');
          setLocalStream(stream);

          // Set call state immediately
          setInCall(true);
          setCallWith(caller);
          setIncomingCall(null);

          // Wait for React to render the video element, then attach stream
          setTimeout(() => {
            if (localVideoRef.current && stream) {
              console.log('üé• Attaching local stream to video element (answerer)');
              localVideoRef.current.srcObject = stream;
              localVideoRef.current.play().catch(err => console.error('Local video play error:', err));
            }
          }, 100);


          
// Fetch TURN credentials dynamically
          let iceServers = [{ urls: "stun:stun.l.google.com:19302" }]; // fallback
          try {
            const response = await fetch("https://global.xirsys.net/_turn/MyFirstApp", {
              method: "PUT",
              headers: {
                "Authorization": "Basic " + btoa("emmaahef:98b96996-0dd0-11f1-a555-0242ac150006"),
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ format: "urls" })
            });
            if (!response.ok) {
              const errText = await response.text();
              console.error("‚ùå Xirsys error:", response.status, errText);
            } else {
              const data = await response.json();
              console.log("‚úÖ Xirsys response:", data);
              if (data.v && data.v.iceServers) {
                const raw = data.v.iceServers;
                const list = Array.isArray(raw) ? raw : [raw];
                console.log("üìã Raw Xirsys servers:", JSON.stringify(list));
                // Xirsys may return 'url' OR 'urls' depending on format - handle both
                iceServers = list
                  .filter(s => s.url || s.urls)
                  .map(s => {
                    const entry = { urls: s.urls || s.url };
                    if (s.username) entry.username = s.username;
                    if (s.credential) entry.credential = s.credential;
                    return entry;
                  });
                console.log("‚úÖ ICE servers ready:", JSON.stringify(iceServers));
              } else {
                console.error("‚ùå Xirsys bad response:", data);
              }
            }
          } catch (err) {
            console.error("‚ùå Xirsys fetch failed:", err);
          }

          // Create peer connection
          const configuration = {
            iceServers: iceServers,
            iceCandidatePoolSize: 10
          };
          console.log("üîß RTCPeerConnection config:", JSON.stringify(configuration));
          const peerConnection = new RTCPeerConnection(configuration);
          peerConnectionRef.current = peerConnection;
          
          // Monitor connection ('disconnected' is transient, only end on failed/closed)
peerConnection.onconnectionstatechange = () => {
  const s = peerConnection.connectionState;
  console.log('Connection state:', s);
  if (s === 'failed' || s === 'closed') endCall();
};
peerConnection.oniceconnectionstatechange = () => {
  const s = peerConnection.iceConnectionState;
  console.log('ICE state:', s);
  if (s === 'failed') endCall();
};


          // CRITICAL FIX: Add tracks BEFORE setting remote description
          stream.getTracks().forEach(track => {
            peerConnection.addTrack(track, stream);
            console.log('‚úÖ Added track:', track.kind);
          });

         // Handle incoming tracks - FIXED
          peerConnection.ontrack = (event) => {
            console.log('üé• RECEIVED REMOTE TRACK:', event.track.kind);
            
            if (event.streams && event.streams[0]) {
              const remoteStream = event.streams[0];
              console.log('Remote stream tracks:', remoteStream.getTracks().length);
              
              setRemoteStream(remoteStream);
              
              // CRITICAL FIX: Wait for element and stream, then attach and play
              setTimeout(() => {
                if (remoteVideoRef.current && remoteStream) {
                  remoteVideoRef.current.srcObject = remoteStream;
                  remoteVideoRef.current.load();
                  
                  remoteVideoRef.current.onloadedmetadata = () => {
                    console.log('‚úÖ Remote video metadata loaded');
                    remoteVideoRef.current.play()
                      .then(() => console.log('‚úÖ Remote video playing'))
                      .catch(err => console.error('Video play error:', err));
                  };
                }
              }, 100);
            }
          };

          // Handle ICE candidates
          peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log('üì° Sending ICE candidate');
              db.ref(`calls/${currentRoom}/${caller}/candidates/${username}`).push({
                candidate: event.candidate.toJSON()
              });
            }
          };

          // Set remote description from offer
          const offerData = incomingCall.offer;
          await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));
          console.log('‚úÖ Set remote description');

          // Create and send answer
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          console.log('‚úÖ Answer created');

          await db.ref(`calls/${currentRoom}/${caller}/answer`).set({
            from: username,
            answer: {
              type: answer.type,
              sdp: answer.sdp
            },
            timestamp: Date.now()
          });
          console.log('‚úÖ Answer sent');

          addDebugLog(`In call with ${caller}`, 'success');

          // Listen for ICE candidates
          const candidatesRef = db.ref(`calls/${currentRoom}/${username}/candidates/${caller}`);
          candidatesRef.on('child_added', async (snapshot) => {
            const data = snapshot.val();
            if (data && data.candidate && peerConnectionRef.current) {
              try {
                await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('‚úÖ Added ICE candidate');
              } catch (err) {
                console.error('ICE error:', err);
              }
            }
          });

          // CRITICAL FIX: Listen for hang-up
          const hangupRef = db.ref(`calls/${currentRoom}/${username}/hangup`);
          hangupRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.from === caller) {
              console.log('üìû Remote peer hung up');
              endCall();
              alert(`${caller} ended the call`);
            }
          });

        } catch (err) {
          console.error('‚ùå Error answering call:', err);
          setError('Failed to answer call: ' + err.message);
          setIncomingCall(null);
        }
      };


const endCall = () => {
  callListenersRef.current.forEach(({ref, ev, fn}) => ref.off(ev, fn));
callListenersRef.current = [];
  console.log('üìû Ending call');
  
  // CRITICAL FIX: Notify the other person
  if (currentRoom && username && callWith) {
    db.ref(`calls/${currentRoom}/${callWith}/hangup`).set({
      from: username,
      timestamp: Date.now()
    });
  }
  
  // CRITICAL FIX: Stop all tracks AND clear video elements
  if (localStream) {
    localStream.getTracks().forEach(track => {
      track.stop();
      console.log('Stopped track:', track.kind);
    });
  }
  
  if (remoteStream) {
    remoteStream.getTracks().forEach(track => {
      track.stop();
    });
  }
  
  // Clear video element sources
  if (localVideoRef.current) {
    localVideoRef.current.srcObject = null;
  }
  if (remoteVideoRef.current) {
    remoteVideoRef.current.srcObject = null;
  }
  
  // Close peer connection
  if (peerConnectionRef.current) {
    peerConnectionRef.current.close();
    peerConnectionRef.current = null;
  }

  // Clean up Firebase
  if (currentRoom && username) {
    db.ref(`calls/${currentRoom}/${username}`).remove();
    if (callWith) {
      db.ref(`calls/${currentRoom}/${callWith}/candidates/${username}`).remove();
    }
  }

  setInCall(false);
  setCallWith(null);
  setLocalStream(null);
  setRemoteStream(null);
  setIsMuted(false);
  setIsVideoOff(false);
  addDebugLog('Call ended', 'info');
};

      const toggleMute = () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) {
            audioTrack.enabled = !audioTrack.enabled;
            setIsMuted(!audioTrack.enabled);
          }
        }
      };

      const toggleVideo = () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) {
            const newState = !videoTrack.enabled;
            videoTrack.enabled = newState;
            setIsVideoOff(!newState);
            // Re-attach stream to video element when turning back on
            if (newState && localVideoRef.current) {
              localVideoRef.current.srcObject = localStream;
              localVideoRef.current.play().catch(err => console.error('Video re-attach error:', err));
            }
          }
        }
      };

  const declineCall = () => {
        console.log('üìû Declining call');
        if (incomingCall) {
          // CRITICAL FIX: Notify caller
          db.ref(`calls/${currentRoom}/${incomingCall.from}/declined`).set(true);
          
          // Clean up
          db.ref(`calls/${currentRoom}/${username}/offer`).remove();
        }
        setIncomingCall(null);
        addDebugLog('Call declined', 'info');
      };

      // ‚îÄ‚îÄ‚îÄ Group Call ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Uses a ref flag (not state) so it never gets wiped by endGroupCall resetting refs
      const groupCallActiveRef = useRef(false);

      const getIceServers = async () => {
        // Always return STUN immediately ‚Äî Xirsys fetch is unreliable and blocks startup
        return [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ];
      };

      const startGroupCall = async () => {
        if (groupCallActiveRef.current) return;   // prevent double-start
        groupCallActiveRef.current = true;
        try {
          addDebugLog('Starting group call...', 'info');
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' },
            audio: { echoCancellation: true, noiseSuppression: true },
          });
          groupLocalStreamRef.current = stream;
          setLocalStream(stream);
          setIsGroupCall(true);
          setInCall(true);

          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
            localVideoRef.current.play().catch(() => {});
          }

          await db.ref(`groupCalls/${currentRoom}/participants/${username}`).set({ joined: Date.now() });
          db.ref(`groupCalls/${currentRoom}/participants/${username}`).onDisconnect().remove();
          await db.ref(`groupCalls/${currentRoom}/active`).set(true);

          const iceServers = await getIceServers();

          // alphabetically smaller name is always the WebRTC initiator
          const iAmInitiator = (other) => username < other;

          const participantsRef = db.ref(`groupCalls/${currentRoom}/participants`);

          // child_added fires for ALL existing keys on attach, then new ones ‚Äî handles everyone
          const handleChildAdded = (childSnap) => {
            const peer = childSnap.key;
            if (peer === username) return;
            if (groupPeerConnectionsRef.current[peer]) return;
            // Don't await here ‚Äî fire and forget so the handler returns synchronously
            createGroupPeer(peer, iceServers, iAmInitiator(peer));
          };

          const handleChildRemoved = (childSnap) => {
            const peer = childSnap.key;
            if (peer === username) return;
            removePeer(peer);
          };

          participantsRef.on('child_added', handleChildAdded);
          participantsRef.on('child_removed', handleChildRemoved);

          groupCallListenersRef.current = [
            { ref: participantsRef, event: 'child_added', fn: handleChildAdded },
            { ref: participantsRef, event: 'child_removed', fn: handleChildRemoved },
          ];

          addDebugLog('Group call started', 'success');
        } catch (err) {
          groupCallActiveRef.current = false;
          console.error('Group call error:', err);
          setError('Failed to start group call: ' + err.message);
          setIsGroupCall(false);
          setInCall(false);
          addDebugLog('Group call error: ' + err.message, 'error');
        }
      };

      const removePeer = (peer) => {
        const pc = groupPeerConnectionsRef.current[peer];
        if (pc) { try { pc.close(); } catch(e) {} }
        delete groupPeerConnectionsRef.current[peer];
        delete participantStreamsRef.current[peer];
        setGroupCallParticipants(prev => prev.filter(p => p !== peer));
      };

      const createGroupPeer = async (participant, iceServers, isInitiator) => {
        // Double-check guard (async gap between check and creation)
        if (groupPeerConnectionsRef.current[participant]) return;

        const stream = groupLocalStreamRef.current;

        // Symmetric pair key ‚Äî identical from both sides
        const [pA, pB] = [username, participant].sort();
        const base       = `groupCalls/${currentRoom}/signals/${pA}__${pB}`;
        const offerPath  = `${base}/offer`;
        const answerPath = `${base}/answer`;
        const myIce      = `${base}/ice_${username}`;
        const theirIce   = `${base}/ice_${participant}`;

        // Initiator clears stale data from previous sessions
        if (isInitiator) {
          try { await db.ref(base).remove(); } catch(e) {}
        }

        const pc = new RTCPeerConnection({ iceServers });
        groupPeerConnectionsRef.current[participant] = pc;

        if (stream) stream.getTracks().forEach(t => pc.addTrack(t, stream));

        // Buffer ICE candidates until remote description is set
        let remoteReady = false;
        const iceBuffer = [];

        const flushIce = async () => {
          remoteReady = true;
          for (const c of iceBuffer.splice(0)) {
            try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {}
          }
        };

        pc.onicecandidate = ({ candidate }) => {
          if (candidate) db.ref(myIce).push({ c: candidate.toJSON() });
        };

        db.ref(theirIce).on('child_added', async snap => {
          const d = snap.val();
          if (!d || !d.c) return;
          if (remoteReady) {
            try { await pc.addIceCandidate(new RTCIceCandidate(d.c)); } catch(e) {}
          } else {
            iceBuffer.push(d.c);
          }
        });

       pc.ontrack = ({streams}) => {
  if (!streams || !streams[0]) return;
  const rs = streams[0];
  participantStreamsRef.current[participant] = rs;
  setGroupCallParticipants(prev =>
    prev.includes(participant) ? prev : [...prev, participant]);

  const attachVideo = () => {
    const el = participantVideoRefs.current[participant];
    if (el) {
      if (el.srcObject !== rs) {
        el.srcObject = rs;
        el.play().catch(e => console.error('Group video play error:', e));
      }
    } else {
      setTimeout(attachVideo, 200);
    }
  };
  attachVideo();
};


        pc.onconnectionstatechange = () => {
          const s = pc.connectionState;
          console.log(`[GroupCall] ${participant}: ${s}`);
          if (s === 'closed') removePeer(participant);
          // 'failed' ‚Äî don't remove immediately, ICE may recover
        };

        if (isInitiator) {
          const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          await pc.setLocalDescription(offer);
          await db.ref(offerPath).set({ type: offer.type, sdp: offer.sdp });

          db.ref(answerPath).on('value', async snap => {
            const d = snap.val();
            if (d && pc.signalingState === 'have-local-offer') {
              try {
                await pc.setRemoteDescription(new RTCSessionDescription(d));
                await flushIce();
                setGroupCallParticipants(prev => prev.includes(participant) ? prev : [...prev, participant]);
              } catch(e) { console.warn('setRemoteDesc answer err', e); }
            }
          });

        } else {
          // Answerer: poll until initiator writes offer
          const offer = await new Promise(resolve => {
            const ref = db.ref(offerPath);
            ref.on('value', snap => {
              if (snap.val()) { ref.off(); resolve(snap.val()); }
            });
          });

          // Guard: make sure PC wasn't closed while we were waiting
          if (pc.signalingState === 'closed') return;

          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          await flushIce();
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await db.ref(answerPath).set({ type: answer.type, sdp: answer.sdp });
          setGroupCallParticipants(prev => prev.includes(participant) ? prev : [...prev, participant]);
        }
      };

      const endGroupCall = () => {
        groupCallActiveRef.current = false;

        // Detach all Firebase listeners
        groupCallListenersRef.current.forEach(({ ref, event, fn }) => ref.off(event, fn));
        groupCallListenersRef.current = [];

        // Close all peer connections
        Object.keys(groupPeerConnectionsRef.current).forEach(peer => {
          try { groupPeerConnectionsRef.current[peer].close(); } catch(e) {}
        });
        groupPeerConnectionsRef.current = {};
        participantStreamsRef.current = {};

        // Stop local camera/mic
        if (groupLocalStreamRef.current) {
          groupLocalStreamRef.current.getTracks().forEach(t => t.stop());
          groupLocalStreamRef.current = null;
        }
        if (localVideoRef.current) localVideoRef.current.srcObject = null;

        // Clean up Firebase presence
        if (currentRoom && username) {
          db.ref(`groupCalls/${currentRoom}/participants/${username}`).remove();
          db.ref(`groupCalls/${currentRoom}/participants`).once('value', snap => {
            if (!snap.val() || Object.keys(snap.val()).length === 0) {
              db.ref(`groupCalls/${currentRoom}/active`).remove();
              db.ref(`groupCalls/${currentRoom}/signals`).remove();
            }
          });
        }

        setIsGroupCall(false);
        setInCall(false);
        setGroupCallParticipants([]);
        setLocalStream(null);
        setIsMuted(false);
        setIsVideoOff(false);
        addDebugLog('Group call ended', 'info');
      };

      // Watch for active group call in room
      useEffect(() => {
        if (currentRoom && db) {
          const activeRef = db.ref(`groupCalls/${currentRoom}/active`);
          activeRef.on('value', snap => {
            setGroupCallActive(!!snap.val());
          });
          return () => activeRef.off();
        }
      }, [currentRoom]);

      // Re-attach streams whenever participants list changes (e.g. new tile rendered)
      // The srcObject !== stream guard ensures we never restart a playing video
      useEffect(() => {
        if (!isGroupCall) return;
        // Small delay so the DOM elements have rendered before we try to attach
        const t = setTimeout(() => {
          groupCallParticipants.forEach(participant => {
            const stream = participantStreamsRef.current[participant];
            const vidEl = participantVideoRefs.current[participant];
            if (vidEl && stream && vidEl.srcObject !== stream) {
              vidEl.srcObject = stream;
              vidEl.play().catch(() => {});
            }
          });
        }, 50);
        return () => clearTimeout(t);
      }, [groupCallParticipants, isGroupCall]);

      // Keep a ref to inCall so the Firebase listener always reads the latest value
      const inCallRef = useRef(false);
      useEffect(() => { inCallRef.current = inCall; }, [inCall]);

      // Listen for incoming calls
      useEffect(() => {
        if (username && currentRoom && db) {
          const callRef = db.ref(`calls/${currentRoom}/${username}/offer`);
          callRef.on('value', (snapshot) => {
            const data = snapshot.val();
            // Use ref so we always have the latest inCall value (avoids stale closure)
            if (data && data.from !== username && !inCallRef.current) {
              setIncomingCall(data);
              addDebugLog(`Incoming call from ${data.from}`, 'info');
            }
          });
          return () => callRef.off();
        }
      }, [username, currentRoom]);

      const updateTyping = () => {
        if (!currentRoom || !username || !db) return;
        db.ref(`typing/${currentRoom}/${username}`).set(Date.now());
        if (typingTimeoutRef.current) {
          clearTimeout(typingTimeoutRef.current);
        }
        typingTimeoutRef.current = setTimeout(() => {
          db.ref(`typing/${currentRoom}/${username}`).remove();
        }, 3000);
      };

      const createRoom = async () => {
        if (!newRoomName.trim()) {
          setError('Room name required');
          addDebugLog('Room creation failed: name required', 'error');
          return;
        }
        const roomId = Date.now().toString();
        const room = {
          id: roomId,
          name: newRoomName.trim(),
          password: newRoomPassword,
          createdAt: Date.now(),
          owner: username
        };
        try {
          await db.ref(`rooms/${roomId}`).set(room);
          addDebugLog(`Room created: ${newRoomName}`, 'success');
          setCurrentRoom(roomId);
          setNewRoomName('');
          setNewRoomPassword('');
          setError('');
          setCurrentView('room');
        } catch (err) {
          setError('Failed to create room');
          addDebugLog(`Room creation error: ${err.message}`, 'error');
        }
      };

      // Game invite handlers
      const sendGameInvite = async (gameType) => {
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        try {
          await db.ref(`gameInvites/${currentRoom}`).set({
            sender: username,
            gameType: gameType,
            timestamp: Date.now()
          });
          addDebugLog(`Sent ${gameType} invite`, 'success');
          setShowGamesMenu(false);
        } catch (err) {
          addDebugLog(`Game invite error: ${err.message}`, 'error');
        }
      };

      const acceptGameInvite = async () => {
        if (!gameInvite) return;
        
        const gameUrls = {
          'gartic': 'https://garlicphone.vercel.app',
          'uno': 'https://unoonline-delta.vercel.app'
        };

        const gameIcons = {
          'gartic': 'üé®',
          'uno': 'üÉè'
        };

        const gameTitles = {
          'gartic': 'Gartic Phone',
          'uno': 'Uno Online'
        };

        const url = gameUrls[gameInvite.gameType];
        if (url) {
          const newWindow = {
            id: Date.now().toString(),
            title: gameTitles[gameInvite.gameType],
            url: url,
            icon: gameIcons[gameInvite.gameType]
          };
          setOpenGameWindows(prev => [...prev, newWindow]);
        }
        
        await db.ref(`gameInvites/${currentRoom}`).remove();
        setGameInvite(null);
      };

      const declineGameInvite = async () => {
        await db.ref(`gameInvites/${currentRoom}`).remove();
        setGameInvite(null);
      };

      const closeGameWindow = (windowId) => {
        setOpenGameWindows(prev => prev.filter(w => w.id !== windowId));
      };

      const joinRoom = (room, password = '') => {
        if (room.password && room.password !== password) {
          setError('Incorrect password');
          addDebugLog(`Failed to join ${room.name}: wrong password`, 'error');
          return;
        }
        setCurrentRoom(room.id);
        setCurrentView('room');
        setError('');
        addDebugLog(`Joining room: ${room.name}`, 'info');
      };

      const sendMessage = async () => {
        if (!message.trim() || !currentRoom || !username) return;
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const newMsg = {
          id: msgId,
          username,
          text: message,
          timestamp: Date.now(),
          reactions: {},
          ...(replyTo && { replyTo: replyTo.id })
        };
        try {
          await db.ref(`messages/${currentRoom}/${msgId}`).set(newMsg);
          setMessage('');
          setReplyTo(null);
          addDebugLog('Message sent', 'success');
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
            db.ref(`typing/${currentRoom}/${username}`).remove();
          }
        } catch (err) {
          setError('Failed to send message');
          addDebugLog(`Message send error: ${err.message}`, 'error');
        }
      };

      const addReaction = async (messageId, emoji) => {
        if (!currentRoom || !db) return;
        try {
          const reactionPath = `messages/${currentRoom}/${messageId}/reactions/${emoji}`;
          const reactionRef = db.ref(reactionPath);
          const snapshot = await reactionRef.once('value');
          const users = snapshot.val() || [];
          if (users.includes(username)) {
            const newUsers = users.filter(u => u !== username);
            if (newUsers.length === 0) {
              await reactionRef.remove();
            } else {
              await reactionRef.set(newUsers);
            }
            addDebugLog(`Removed reaction ${emoji}`, 'info');
          } else {
            await reactionRef.set([...users, username]);
            addDebugLog(`Added reaction ${emoji}`, 'success');
          }
        } catch (err) {
          addDebugLog(`Reaction error: ${err.message}`, 'error');
        }
      };

      const clearAllMessages = async () => {
        const currentRoomData = rooms.find(r => r.id === currentRoom);
        if (!currentRoomData || currentRoomData.owner !== username) {
          alert('‚ùå Only the room owner can clear messages!');
          addDebugLog('Clear messages denied: not owner', 'warning');
          return;
        }
        if (!confirm('‚ö†Ô∏è Clear all messages in this room?')) return;
        try {
          await db.ref(`messages/${currentRoom}`).remove();
          addDebugLog('All messages cleared', 'success');
        } catch (err) {
          setError('Failed to clear messages');
          addDebugLog(`Clear messages error: ${err.message}`, 'error');
        }
      };
  
const kickUser = async (targetUser) => {
  const currentRoomData = rooms.find(r => r.id === currentRoom);
  if (!currentRoomData || (currentRoomData.owner !== username && username !== 'emmaowner')) {
    alert('‚ùå Only the room owner can kick users!');
    addDebugLog('Kick denied: not owner', 'warning');
    return;
  }
  if (!confirm(`‚ö†Ô∏è Kick ${targetUser} from the room?`)) return;
  
  try {
    // Remove user from room
    await db.ref(`roomUsers/${currentRoom}/${targetUser}`).remove();
    
    // Mark them as kicked so they can't rejoin
    await db.ref(`kicked/${currentRoom}/${targetUser}`).set(true);
    
    // Send system message
    const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const systemMsg = {
      id: msgId,
      type: 'system',
      text: `${targetUser} was kicked from the room`,
      timestamp: Date.now()
    };
    await db.ref(`messages/${currentRoom}/${msgId}`).set(systemMsg);
    
    addDebugLog(`Kicked user: ${targetUser}`, 'success');
    alert(`‚úÖ ${targetUser} has been kicked!`);
  } catch (err) {
    setError('Failed to kick user');
    addDebugLog(`Kick error: ${err.message}`, 'error');
  }
};

      const leaveRoom = async () => {
        if (!currentRoom || !username) return;
        const msgId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const systemMsg = {
          id: msgId,
          type: 'system',
          text: `${username} left the room`,
          timestamp: Date.now()
        };
        try {
          await db.ref(`messages/${currentRoom}/${msgId}`).set(systemMsg);
          await db.ref(`roomUsers/${currentRoom}/${username}`).remove();
          addDebugLog('Left room', 'info');
        } catch (err) {
          addDebugLog(`Leave room error: ${err.message}`, 'error');
        }
        setCurrentRoom(null);
        setCurrentView('lobby');
        setMessages([]);
      };

      const deleteRoom = async (roomId, e) => {
        e.stopPropagation();
        const room = rooms.find(r => r.id === roomId);
        if (room && room.owner !== username && username !== 'emmaowner') {
          alert('‚ùå Only the room owner can delete this room!');
          addDebugLog('Delete denied: not owner', 'warning');
          return;
        }
        if (!confirm('‚ö†Ô∏è Delete this room and all messages?')) return;
        try {
          await db.ref(`rooms/${roomId}`).remove();
          await db.ref(`messages/${roomId}`).remove();
          await db.ref(`roomUsers/${roomId}`).remove();
          await db.ref(`typing/${roomId}`).remove();
          addDebugLog(`Room deleted: ${room.name}`, 'success');
        } catch (err) {
          setError('Failed to delete room');
          addDebugLog(`Delete room error: ${err.message}`, 'error');
        }
      };

      const formatTime = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      };

      const getReplyMessage = (replyToId) => {
        return messages.find(m => m.id === replyToId);
      };

      if (currentView === 'start') {
        return (
          <>
            <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', borderRadius: '20px', padding: '40px', width: '100%', maxWidth: '400px', border: '1px solid #333' }}>
                <div style={{ textAlign: 'center', marginBottom: '30px' }}>
                  <div className="glow" style={{ display: 'inline-block' }}><MessageCircle /></div>
                  <h1 className="glow-text" style={{ fontSize: '32px', fontWeight: 'bold', marginTop: '20px', marginBottom: '10px' }}>CHATROOMS</h1>
                  <p style={{ color: '#999' }}>Enter the void</p>
                </div>
                <input
                  type="text"
                  value={tempUsername}
                  onChange={(e) => setTempUsername(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && tempUsername.trim() && (setUsername(tempUsername.trim()), setCurrentView('lobby'))}
                  placeholder="Choose username..."
                  style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '20px' }}
                />
                <div style={{ display: 'grid', gap: '10px' }}>
                  <button onClick={() => tempUsername.trim() ? (setUsername(tempUsername.trim()), setCurrentView('lobby')) : setError('Enter a username')} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>JOIN ROOM</button>
                  <button onClick={() => tempUsername.trim() ? (setUsername(tempUsername.trim()), setCurrentView('create')) : setError('Enter a username')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE ROOM</button>
                </div>
                {error && <div style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', marginTop: '15px' }}>{error}</div>}
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'create') {
        return (
          <>
            <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', borderRadius: '20px', padding: '40px', width: '100%', maxWidth: '500px', border: '1px solid #333' }}>
                <div style={{ textAlign: 'center', marginBottom: '30px' }}>
                  <div className="glow" style={{ display: 'inline-block' }}><Plus /></div>
                  <h1 className="glow-text" style={{ fontSize: '28px', fontWeight: 'bold', marginTop: '20px', marginBottom: '10px' }}>CREATE ROOM</h1>
                  <p style={{ color: '#999' }}>User: {username}</p>
                </div>
                <input type="text" value={newRoomName} onChange={(e) => setNewRoomName(e.target.value)} placeholder="Room name..." style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '15px' }} />
                <input type="password" value={newRoomPassword} onChange={(e) => setNewRoomPassword(e.target.value)} placeholder="Password (optional)..." style={{ width: '100%', padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '16px', marginBottom: '20px' }} />
                <div style={{ display: 'grid', gap: '10px' }}>
                  <button onClick={createRoom} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE & ENTER</button>
                  <button onClick={() => setCurrentView('lobby')} style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>BACK</button>
                </div>
                {error && <div style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', marginTop: '15px' }}>{error}</div>}
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'lobby') {
        return (
          <>
            <div style={{ minHeight: '100vh', padding: '20px' }}>
              <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                <div style={{ textAlign: 'center', marginBottom: '40px' }}>
                  <h1 className="glow-text" style={{ fontSize: '36px', fontWeight: 'bold', marginBottom: '10px' }}>ACTIVE ROOMS</h1>
                  <p style={{ color: '#999', fontSize: '16px' }}>User: {username}</p>
                </div>
                <div style={{ display: 'grid', gap: '15px', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))' }}>
                  {rooms.length === 0 ? (
                    <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '60px 20px', background: '#0a0a0a', borderRadius: '15px', border: '1px solid #333' }}>
                      <p style={{ color: '#666', fontSize: '18px', marginBottom: '20px' }}>No rooms yet. Create one!</p>
                      <button onClick={() => setCurrentView('create')} className="glow-button" style={{ background: '#fff', color: '#000', padding: '15px 30px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>CREATE ROOM</button>
                    </div>
                  ) : (
                    rooms.map(room => (
                      <div key={room.id} className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderRadius: '15px', border: '1px solid #333', display: 'flex', flexDirection: 'column', gap: '15px' }}>
                        <div>
                          <h3 style={{ fontSize: '20px', fontWeight: 'bold', marginBottom: '8px' }}>{room.name}</h3>
                          <div style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#999', fontSize: '13px', flexWrap: 'wrap' }}>
                            <span>by {room.owner}</span>
                            {room.password && <span style={{ background: '#1a1a1a', padding: '4px 8px', borderRadius: '6px', border: '1px solid #333' }}>üîí Private</span>}
                          </div>
                        </div>
                        <div style={{ display: 'flex', gap: '10px' }}>
                          <button onClick={() => room.password ? (() => {
                            const pwd = prompt('Enter password:');
                            if (pwd !== null) joinRoom(room, pwd);
                          })() : joinRoom(room)} className="glow-button" style={{ flex: 1, background: '#fff', color: '#000', padding: '12px', borderRadius: '8px', border: 'none', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer' }}>
                            JOIN
                          </button>
                          {(room.owner === username || username === 'emmaowner') && (
                            <button onClick={(e) => deleteRoom(room.id, e)}
                              style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '10px', borderRadius: '8px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '5px' }}>
                              <Trash /> Delete
                            </button>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      if (currentView === 'room') {
        const currentRoomData = rooms.find(r => r.id === currentRoom);
        const isOwner = currentRoomData && currentRoomData.owner === username;

        return (
          <>
            <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
              <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderBottom: '1px solid #333' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '15px' }}>
                  <div>
                    <h2 className="glow-text" style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '5px' }}>
                      {currentRoomData?.name || 'Room'}
                    </h2>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#999', fontSize: '13px' }}>
                      <span>{roomUsers.length} {roomUsers.length === 1 ? 'user' : 'users'} in room</span>
                      {isOwner && <span style={{ background: '#1a1a1a', padding: '4px 10px', borderRadius: '6px', border: '1px solid #333' }}>üëë Owner</span>}
                    </div>
                  </div>
                  <div style={{ display: 'flex', gap: '10px' }}>
                    {isOwner && (
                      <button onClick={clearAllMessages} style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '10px 20px', borderRadius: '8px', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <Trash /> Clear All
                      </button>
                    )}
                    {!inCall && (
                      <button onClick={startGroupCall} className="glow-button" style={{ background: '#1a1a1a', color: '#00ff88', padding: '10px 20px', borderRadius: '8px', border: '1px solid #00ff88', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                        üìπ Group Call
                      </button>
                    )}
                    <button onClick={() => setShowGamesMenu(!showGamesMenu)} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '10px 20px', borderRadius: '8px', border: '1px solid #333', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <Gamepad /> Games
                    </button>
                    <button onClick={leaveRoom} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '10px 20px', borderRadius: '8px', border: '1px solid #333', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <LogOut /> Leave
                    </button>
                  </div>
                </div>
              </div>

              {/* Active group call banner for users not in call */}
              {groupCallActive && !inCall && (
                <div style={{ background: 'linear-gradient(90deg, #003322, #004433)', padding: '10px 20px', borderBottom: '1px solid #00ff88', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#00ff88', fontSize: '14px', fontWeight: 'bold' }}>
                    <span style={{ animation: 'glow 1s ease-in-out infinite' }}>üî¥</span>
                    Group call in progress
                  </div>
                  <button
                    onClick={startGroupCall}
                    style={{ background: '#00ff88', color: '#000', padding: '8px 20px', borderRadius: '8px', border: 'none', fontSize: '13px', fontWeight: 'bold', cursor: 'pointer' }}
                  >
                    Join Call
                  </button>
                </div>
              )}

              {roomUsers.length > 1 && (
                <div style={{ background: '#0a0a0a', padding: '10px 20px', borderBottom: '1px solid #333' }}>
                  <div style={{ maxWidth: '1200px', margin: '0 auto', display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
                    <Users style={{ width: '16px', height: '16px' }} />
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                      {roomUsers.map(user => (
                        <div key={user} style={{ background: '#1a1a1a', padding: '6px 12px', borderRadius: '8px', border: '1px solid #333', fontSize: '13px', display: 'flex', alignItems: 'center', gap: '8px' }}>
                          <span>{user}</span>
                          {user === currentRoomData?.owner && <span>üëë</span>}
                          {user !== username && !inCall && (
                            <button 
                              onClick={() => startCall(user)} 
                              style={{ 
                                background: 'transparent', 
                                border: 'none', 
                                color: '#00ff88', 
                                cursor: 'pointer', 
                                padding: '0 5px',
                                fontSize: '16px'
                              }}
                              title={`Call ${user}`}
                            >
                              üìû
                            </button>
                          )}
                          {isOwner && user !== username && (
                            <button onClick={() => kickUser(user)} style={{ background: 'transparent', border: 'none', color: '#ff6666', cursor: 'pointer', padding: '0 5px' }}>
                              <UserX style={{ width: '14px', height: '14px' }} />
                            </button>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              )}

              <div style={{ flex: 1, overflow: 'auto', background: '#000', padding: '20px' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                  
                  {gameInvite && (
                    <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', marginBottom: '20px', borderRadius: '15px', border: '2px solid #4a9eff', animation: 'glow 2s ease-in-out infinite' }}>
                      <div style={{ textAlign: 'center' }}>
                        <div style={{ fontSize: '24px', marginBottom: '10px' }}>üéÆ</div>
                        <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '10px' }}>
                          {gameInvite.sender} wants to play {gameInvite.gameType === 'gartic' ? 'Gartic Phone' : 'Uno'}!
                        </div>
                        <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
                          <button onClick={acceptGameInvite} className="glow-button" style={{ background: '#00ff00', color: '#000', padding: '12px 24px', borderRadius: '8px', border: 'none', fontSize: '14px', fontWeight: 'bold', cursor: 'pointer' }}>
                            ‚úì Accept
                          </button>
                          <button onClick={declineGameInvite} style={{ background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '12px 24px', borderRadius: '8px', cursor: 'pointer', fontSize: '14px', fontWeight: 'bold' }}>
                            ‚úï Decline
                          </button>
                        </div>
                      </div>
                    </div>
                  )}

                  {showGamesMenu && (
                    <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setShowGamesMenu(false)}>
                      <div className="glow-border" style={{ background: '#0a0a0a', padding: '30px', borderRadius: '20px', maxWidth: '400px', width: '90%' }} onClick={(e) => e.stopPropagation()}>
                        <h3 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '20px', textAlign: 'center' }}>üéÆ Choose a Game</h3>
                        <div style={{ display: 'grid', gap: '10px' }}>
                          <button onClick={() => sendGameInvite('gartic')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            üé® Gartic Phone
                          </button>
                          <button onClick={() => sendGameInvite('uno')} className="glow-button" style={{ width: '100%', background: '#1a1a1a', color: '#fff', padding: '15px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            üÉè Uno Online
                          </button>
                          <button onClick={() => setShowGamesMenu(false)} style={{ width: '100%', background: '#2a0000', border: '1px solid #ff0000', color: '#ff6666', padding: '15px', borderRadius: '10px', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                            Cancel
                          </button>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  {messages.map((msg) => {
                    if (msg.type === 'system') {
                      return <div key={msg.id} className="system-message">{msg.text}</div>;
                    }


                    const replyMsg = msg.replyTo ? getReplyMessage(msg.replyTo) : null;
                    const userColor = `hsl(${msg.username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360}, 70%, 60%)`;

                    return (
                      <div key={msg.id} className="message-bubble" style={{ marginBottom: '15px', background: msg.username === username ? '#1a1a1a' : '#0a0a0a', padding: '15px', borderRadius: '15px', border: '1px solid #333' }}>
                        <div className="message-actions">
                          <button onClick={() => setReplyTo(msg)} className="action-btn">Reply</button>
                          <button onClick={() => setShowEmojiPicker(showEmojiPicker === msg.id ? null : msg.id)} className="action-btn">
                            <Smile />
                          </button>
                        </div>

                        {showEmojiPicker === msg.id && (
                          <div className="emoji-picker">
                            {EMOJIS.map(emoji => (
                              <button key={emoji} onClick={() => {
                                addReaction(msg.id, emoji);
                                setShowEmojiPicker(null);
                              }} className="emoji-btn">
                                {emoji}
                              </button>
                            ))}
                          </div>
                        )}

                        <div style={{ display: 'flex', alignItems: 'baseline', gap: '10px', marginBottom: '8px' }}>
                          <span style={{ color: userColor, fontWeight: 'bold', fontSize: '14px' }}>{msg.username}</span>
                          <span style={{ color: '#666', fontSize: '12px' }}>{formatTime(msg.timestamp)}</span>
                        </div>

                        {replyMsg && (
                          <div className="reply-to" style={{ borderColor: userColor }}>
                            <div style={{ fontSize: '11px', color: '#999', marginBottom: '4px' }}>Replying to {replyMsg.username}</div>
                            <div style={{ fontSize: '12px', opacity: 0.7 }}>{replyMsg.text.substring(0, 50)}{replyMsg.text.length > 50 ? '...' : ''}</div>
                          </div>
                        )}

                        {msg.type === 'snap' && msg.image ? (
                          <div style={{ marginTop: '8px' }}>
                            <img 
                              src={msg.image} 
                              alt="Snap" 
                              style={{ 
                                maxWidth: '100%', 
                                maxHeight: '400px', 
                                borderRadius: '10px',
                                cursor: 'pointer'
                              }} 
                            />
                          </div>
                        ) : msg.type === 'video' && msg.videoUrl ? (
                          <div style={{ marginTop: '8px' }}>
                            <video 
                              src={msg.videoUrl} 
                              controls 
                              style={{ 
                                maxWidth: '100%', 
                                maxHeight: '400px', 
                                borderRadius: '10px'
                              }} 
                            />
                          </div>
                        ) : (
                          <div style={{ fontSize: '15px', lineHeight: '1.5', wordBreak: 'break-word' }}>{msg.text}</div>
                        )}

                        {msg.reactions && Object.keys(msg.reactions).length > 0 && (
                          <div className="reaction-container">
                            {Object.entries(msg.reactions).map(([emoji, users]) => (
                              <div key={emoji} onClick={() => addReaction(msg.id, emoji)} className={`reaction ${users.includes(username) ? 'active' : ''}`}>
                                <span>{emoji}</span>
                                <span>{users.length}</span>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    );
                  })}

                  {typingUsers.length > 0 && (
                    <div className="typing-indicator">
                      {typingUsers.join(', ')} {typingUsers.length === 1 ? 'is' : 'are'} typing...
                    </div>
                  )}

                  <div ref={messagesEndRef} />
                </div>
              </div>

              <div className="glow-border" style={{ background: '#0a0a0a', padding: '20px', borderTop: '1px solid #333' }}>
                <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                  {replyTo && (
                    <div className="reply-preview">
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '5px' }}>
                        <span style={{ fontSize: '12px', color: '#999' }}>Replying to {replyTo.username}</span>
                        <button onClick={() => setReplyTo(null)} style={{ background: 'transparent', border: 'none', color: '#666', cursor: 'pointer', fontSize: '18px', lineHeight: 1 }}>√ó</button>
                      </div>
                      <div style={{ fontSize: '13px', opacity: 0.8 }}>{replyTo.text.substring(0, 80)}{replyTo.text.length > 80 ? '...' : ''}</div>
                    </div>
                  )}


                  {showImageInput && (
                    <div style={{ marginBottom: '15px', background: '#1a1a1a', padding: '20px', borderRadius: '15px', border: '1px solid #333' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                        <h3 style={{ fontSize: '16px', fontWeight: 'bold' }}>üñºÔ∏è Send Image/GIF</h3>
                        <button onClick={() => setShowImageInput(false)} style={{ background: 'transparent', border: 'none', color: '#999', cursor: 'pointer', fontSize: '24px' }}>√ó</button>
                      </div>
                      <div style={{ marginBottom: '10px', padding: '8px', background: '#0a2a0a', border: '1px solid #00ff88', borderRadius: '8px', color: '#88ffcc', fontSize: '12px' }}>
                        üí° <strong>Tip:</strong> You can paste Giphy page URLs directly! Or use "Share" ‚Üí "Copy GIF Link" from Giphy/Tenor
                      </div>
                      <input
                        type="text"
                        value={imageUrl}
                        onChange={(e) => setImageUrl(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && sendImageUrl()}
                        placeholder="Paste image or GIF URL..."
                        style={{ width: '100%', padding: '15px', background: '#0a0a0a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '15px', marginBottom: '15px' }}
                      />
                      {imageUrl && (
                        <div style={{ marginBottom: '15px', textAlign: 'center' }}>
                          <img src={imageUrl} alt="Preview" style={{ maxWidth: '100%', maxHeight: '200px', borderRadius: '10px' }} onError={(e) => e.target.style.display = 'none'} />
                        </div>
                      )}
                      <button onClick={sendImageUrl} className="glow-button" style={{ width: '100%', background: '#fff', color: '#000', padding: '15px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                        üì§ SEND IMAGE
                      </button>
                    </div>
                  )}

                  <div style={{ display: 'flex', gap: '10px' }}>
                    <input
                      type="text"
                      value={message}
                      onChange={(e) => {
                        setMessage(e.target.value);
                        updateTyping();
                      }}
                      onKeyDown={(e) => e.key === 'Enter' && sendMessage()}
                      placeholder="Type a message..."
                      style={{ flex: 1, padding: '15px', background: '#1a1a1a', border: '1px solid #333', borderRadius: '10px', color: '#fff', fontSize: '15px' }}
                    />
                    <button onClick={sendMessage} className="glow-button" style={{ background: '#fff', color: '#000', padding: '15px 30px', borderRadius: '10px', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <Send /> Send
                    </button>
                    <button onClick={openSnapCamera} className="glow-button" style={{ background: '#ffeb3b', color: '#000', padding: '15px 30px', borderRadius: '10px', border: 'none', fontSize: '20px', fontWeight: 'bold', cursor: 'pointer' }} title="Take a snap">
                      üì∏
                    </button>
                    <button onClick={() => setShowImageInput(!showImageInput)} className="glow-button" style={{ background: '#1a1a1a', color: '#fff', padding: '15px 30px', borderRadius: '10px', border: '1px solid #333', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer' }}>
                      üñºÔ∏è
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {/* Render open game windows */}
            {openGameWindows.map(window => (
              <MinimizedWindow 
                key={window.id}
                title={window.title}
                url={window.url}
                icon={window.icon}
                onClose={() => closeGameWindow(window.id)}
              />
            ))}

            {/* Group Call Modal */}
            {isGroupCall && inCall && (
              <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: '#111', zIndex: 10000, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>

                {/* Waiting state: small self-view + big waiting message */}
                {groupCallParticipants.length === 0 ? (
                  <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', gap: '20px', minHeight: 0 }}>
                    {/* Self preview - small box */}
                    <div style={{ position: 'relative', width: '260px', height: '200px', borderRadius: '16px', overflow: 'hidden', border: '2px solid #333', background: '#000', flexShrink: 0 }}>
                      <video ref={localVideoRef} autoPlay playsInline muted
                        style={{ width: '100%', height: '100%', objectFit: 'cover', display: isVideoOff ? 'none' : 'block' }} />
                      {isVideoOff && <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '36px' }}>üìπ</div>}
                      <div style={{ position: 'absolute', bottom: '8px', left: '10px', background: 'rgba(0,0,0,0.6)', padding: '3px 8px', borderRadius: '6px', fontSize: '12px', color: '#fff' }}>{username} (you)</div>
                    </div>
                    <div style={{ textAlign: 'center', color: '#666' }}>
                      <div style={{ fontSize: '36px', marginBottom: '12px' }}>üë•</div>
                      <div style={{ fontSize: '18px', fontWeight: 'bold', color: '#fff', marginBottom: '6px' }}>You're in the group call</div>
                      <div style={{ fontSize: '14px' }}>Waiting for others to join...</div>
                    </div>
                  </div>
                ) : (
                  /* Active grid when others are present */
                  <div style={{
                    flex: 1,
                    display: 'grid',
                    gridTemplateColumns: groupCallParticipants.length === 1 ? '1fr 1fr' :
                                         groupCallParticipants.length <= 3 ? 'repeat(2, 1fr)' :
                                         'repeat(3, 1fr)',
                    gridAutoRows: groupCallParticipants.length <= 1 ? '1fr' : 'auto',
                    gap: '4px',
                    padding: '8px',
                    minHeight: 0,
                    overflow: 'hidden'
                  }}>
                    {/* Local tile */}
                    <div style={{ position: 'relative', background: '#000', borderRadius: '12px', overflow: 'hidden', minHeight: '160px' }}>
                      <video ref={localVideoRef} autoPlay playsInline muted
                        style={{ width: '100%', height: '100%', objectFit: 'cover', display: isVideoOff ? 'none' : 'block', position: 'absolute', inset: 0 }} />
                      {isVideoOff && <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '36px' }}>üìπ</div>}
                      <div style={{ position: 'absolute', bottom: '8px', left: '10px', background: 'rgba(0,0,0,0.6)', padding: '3px 8px', borderRadius: '6px', fontSize: '12px', color: '#fff' }}>{username} (you)</div>
                    </div>

                    {/* Remote tiles */}
                    {groupCallParticipants.map(participant => (
                      <div key={participant} style={{ position: 'relative', background: '#000', borderRadius: '12px', overflow: 'hidden', minHeight: '160px' }}>
                        <video
                          ref={el => {
                            // Only update srcObject when the element mounts or the stream changes ‚Äî not on every render
                            const prev = participantVideoRefs.current[participant];
                            participantVideoRefs.current[participant] = el;
                            if (el) {
                              const stream = participantStreamsRef.current[participant];
                              if (stream && el.srcObject !== stream) {
                                el.srcObject = stream;
                                el.play().catch(() => {});
                              }
                            } else if (prev) {
                              prev.srcObject = null;
                            }
                          }}
                          autoPlay playsInline
                          style={{ width: '100%', height: '100%', objectFit: 'cover', position: 'absolute', inset: 0 }}
                        />
                        <div style={{ position: 'absolute', bottom: '8px', left: '10px', background: 'rgba(0,0,0,0.6)', padding: '3px 8px', borderRadius: '6px', fontSize: '12px', color: '#fff' }}>{participant}</div>
                      </div>
                    ))}
                  </div>
                )}

                {/* Controls bar - always visible, never hidden */}
                <div style={{ flexShrink: 0, padding: '16px', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '20px', background: '#000', borderTop: '1px solid #222' }}>
                  <button onClick={toggleMute} className={`call-btn mute ${isMuted ? 'active' : ''}`} title={isMuted ? 'Unmute' : 'Mute'}>
                    {isMuted ? 'üîá' : 'üé§'}
                  </button>
                  <button onClick={toggleVideo} className={`call-btn video-toggle ${isVideoOff ? 'active' : ''}`} title={isVideoOff ? 'Turn on camera' : 'Turn off camera'}>
                    {isVideoOff ? 'üìπ' : 'üì∑'}
                  </button>
                  <button onClick={endGroupCall} className="call-btn end" title="Leave call">
                    ‚òéÔ∏è
                  </button>
                </div>
              </div>
            )}

            {/* Video Call Modal */}
            {!isGroupCall && inCall && (
              <div className="video-call-modal">
                <div className="video-container">
                  <video 
                    ref={remoteVideoRef} 
                    autoPlay 
                    playsInline
                    controls={false}
                    className="remote-video"
                    style={{ 
                      display: remoteStream ? 'block' : 'none',
                      width: '100%',
                      height: '100%',
                      objectFit: 'cover'
                    }}
                  />
                  {!remoteStream && (
                    <div className="call-status">
                      <div style={{ fontSize: '48px', marginBottom: '20px' }}>üìû</div>
                      <div>Calling {callWith}...</div>
                      <div style={{ fontSize: '14px', color: '#999', marginTop: '10px' }}>Waiting for them to answer...</div>
                    </div>
                  )}
                  
                  {/* Local video - always keep in DOM so ref stays valid */}
                  <video 
                    ref={localVideoRef} 
                    autoPlay 
                    playsInline 
                    muted 
                    className="local-video"
                    style={{
                      position: 'absolute',
                      top: '20px',
                      right: '20px',
                      width: '220px',
                      height: '280px',
                      borderRadius: '15px',
                      border: '2px solid #fff',
                      objectFit: 'cover',
                      boxShadow: '0 4px 15px rgba(0,0,0,0.5)',
                      zIndex: 10,
                      display: isVideoOff ? 'none' : 'block'
                    }}
                  />
                  {isVideoOff && (
                    <div 
                      style={{ 
                        position: 'absolute',
                        top: '20px',
                        right: '20px',
                        width: '220px',
                        height: '280px',
                        borderRadius: '15px',
                        border: '2px solid #fff',
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center', 
                        background: '#1a1a1a',
                        boxShadow: '0 4px 15px rgba(0,0,0,0.5)',
                        zIndex: 10
                      }}
                    >
                      <span style={{ fontSize: '48px' }}>üìπ</span>
                    </div>
                  )}
                  
                  {/* In-call chat notifications */}
                  {inCallNotifications.map(notif => (
                    <div
                      key={notif.id}
                      style={{
                        position: 'absolute',
                        top: '20px',
                        left: '20px',
                        maxWidth: '300px',
                        background: 'rgba(0, 0, 0, 0.9)',
                        border: '1px solid rgba(255, 255, 255, 0.3)',
                        borderRadius: '15px',
                        padding: '15px',
                        zIndex: 10,
                        animation: 'slideIn 0.3s ease-out',
                        backdropFilter: 'blur(10px)',
                        boxShadow: '0 4px 20px rgba(0, 0, 0, 0.5)'
                      }}
                    >
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                        <div style={{ fontWeight: 'bold', fontSize: '14px' }}>üí¨ {notif.from}</div>
                        <button
                          onClick={() => dismissNotification(notif.id)}
                          style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#999',
                            cursor: 'pointer',
                            fontSize: '16px',
                            padding: '0 5px'
                          }}
                        >
                          ‚úï
                        </button>
                      </div>
                      <div style={{ 
                        fontSize: '13px', 
                        color: '#ccc', 
                        marginBottom: '10px',
                        wordBreak: 'break-word',
                        maxHeight: '60px',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis'
                      }}>
                        {notif.text}
                      </div>
                      <button
                        onClick={() => dismissNotification(notif.id)}
                        style={{
                          background: 'rgba(255, 255, 255, 0.2)',
                          border: '1px solid rgba(255, 255, 255, 0.3)',
                          color: '#fff',
                          padding: '6px 12px',
                          borderRadius: '8px',
                          fontSize: '12px',
                          cursor: 'pointer',
                          width: '100%',
                          transition: 'all 0.2s'
                        }}
                        onMouseEnter={(e) => e.target.style.background = 'rgba(255, 255, 255, 0.3)'}
                        onMouseLeave={(e) => e.target.style.background = 'rgba(255, 255, 255, 0.2)'}
                      >
                        Dismiss
                      </button>
                    </div>
                  ))}

                  <div className="call-controls">
                    <button 
                      onClick={toggleMute} 
                      className={`call-btn mute ${isMuted ? 'active' : ''}`}
                      title={isMuted ? 'Unmute' : 'Mute'}
                    >
                      {isMuted ? 'üîá' : 'üé§'}
                    </button>
                    <button 
                      onClick={toggleVideo} 
                      className={`call-btn video-toggle ${isVideoOff ? 'active' : ''}`}
                      title={isVideoOff ? 'Turn on camera' : 'Turn off camera'}
                    >
                      {isVideoOff ? 'üìπ' : 'üì∑'}
                    </button>
                    <button 
                      onClick={endCall} 
                      className="call-btn end"
                      title="End call"
                    >
                      ‚òéÔ∏è
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Incoming Call */}
            {incomingCall && !inCall && !isGroupCall && (
              <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10001 }}>
                <div className="incoming-call">
                  <div style={{ fontSize: '64px', marginBottom: '20px', animation: 'glow 1s ease-in-out infinite' }}>üìû</div>
                  <h2 style={{ fontSize: '24px', fontWeight: 'bold', marginBottom: '10px' }}>Incoming Call</h2>
                  <p style={{ fontSize: '18px', color: '#999', marginBottom: '30px' }}>{incomingCall.from} is calling you...</p>
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button 
                      onClick={() => answerCall(incomingCall.from)} 
                      className="glow-button" 
                      style={{ 
                        background: '#00ff00', 
                        color: '#000', 
                        padding: '15px 40px', 
                        borderRadius: '50px', 
                        border: 'none', 
                        fontSize: '18px', 
                        fontWeight: 'bold', 
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '10px'
                      }}
                    >
                      üìû Answer
                    </button>
                    <button 
                      onClick={declineCall} 
                      style={{ 
                        background: '#ff3b30', 
                        color: '#fff', 
                        padding: '15px 40px', 
                        borderRadius: '50px', 
                        border: 'none', 
                        fontSize: '18px', 
                        fontWeight: 'bold', 
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '10px'
                      }}
                    >
                      ‚ùå Decline
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Snap Camera Modal */}
            {showSnapCamera && (
              <div className="snap-camera-modal">
                <button onClick={closeSnapCamera} className="snap-close-btn">
                  ‚úï
                </button>
                
                {/* Mode toggle button */}
                <button 
                  onClick={toggleCaptureMode}
                  style={{
                    position: 'absolute',
                    top: '20px',
                    right: '20px',
                    padding: '10px 20px',
                    borderRadius: '50px',
                    background: captureMode === 'photo' ? '#ffeb3b' : '#ff4444',
                    color: '#000',
                    border: 'none',
                    fontSize: '14px',
                    fontWeight: 'bold',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                    zIndex: 11,
                    transition: 'all 0.2s'
                  }}
                >
                  {captureMode === 'photo' ? 'üì∏ Photo' : 'üé• Video'}
                </button>
                
                <div className="snap-video-container">
                  {!capturedSnap && !recordedVideo ? (
                    <>
                      <video 
                        ref={snapVideoRef} 
                        autoPlay 
                        playsInline 
                        muted
                        className="snap-video"
                        style={{ transform: isFrontCamera ? 'scaleX(-1)' : 'none' }}
                      />
                      
                      {/* Recording indicator */}
                      {isRecording && (
                        <div style={{
                          position: 'absolute',
                          top: '80px',
                          left: '50%',
                          transform: 'translateX(-50%)',
                          background: 'rgba(255, 0, 0, 0.9)',
                          color: '#fff',
                          padding: '10px 20px',
                          borderRadius: '50px',
                          fontSize: '16px',
                          fontWeight: 'bold',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '10px',
                          zIndex: 11
                        }}>
                          <div style={{
                            width: '12px',
                            height: '12px',
                            borderRadius: '50%',
                            background: '#fff',
                            animation: 'glow 1s ease-in-out infinite'
                          }} />
                          {Math.floor(recordingTime / 60)}:{(recordingTime % 60).toString().padStart(2, '0')}
                        </div>
                      )}
                      
                      <div className="snap-controls">
                        <button onClick={flipCamera} className="snap-action-btn" title="Flip camera">
                          üîÑ
                        </button>
                        
                        {captureMode === 'photo' ? (
                          <button onClick={captureSnap} className="snap-capture-btn" title="Capture photo" />
                        ) : (
                          <button 
                            onClick={isRecording ? stopRecording : startRecording}
                            className="snap-capture-btn"
                            style={{
                              background: isRecording ? '#ff4444' : '#fff',
                              border: isRecording ? '5px solid #fff' : '5px solid rgba(255, 255, 255, 0.3)'
                            }}
                            title={isRecording ? 'Stop recording' : 'Start recording'}
                          />
                        )}
                      </div>
                    </>
                  ) : (
                    <>
                      {capturedSnap && (
                        <img src={capturedSnap} className="snap-preview-image" alt="Captured snap" />
                      )}
                      {recordedVideo && (
                        <video src={recordedVideo} className="snap-preview-image" controls autoPlay loop />
                      )}
                      <div className="snap-controls">
                        <button onClick={retakeSnap} className="snap-action-btn" title="Retake">
                          ‚Ü∫
                        </button>
                      </div>
                      <button onClick={sendSnap} className="snap-send-btn">
                        üì§ Send {capturedSnap ? 'Snap' : 'Video'}
                      </button>
                    </>
                  )}
                  <canvas ref={snapCanvasRef} style={{ display: 'none' }} />
                </div>
              </div>
            )}

            {!showDebug && (
              <div className="debug-toggle" onClick={() => setShowDebug(true)}>
                <Bug />
              </div>
            )}
            {showDebug && <DebugConsole logs={logs} onClose={() => setShowDebug(false)} />}
          </>
        );
      }

      return null;
    }

    ReactDOM.render(<ChatroomApp />, document.getElementById('root'));
  </script>

  <!-- ‚îÄ‚îÄ PROXY BROWSER ‚îÄ‚îÄ -->
<button class="proxy-fab" id="proxyFab" title="Open Browser" onclick="openProxy()">üåê</button>


  <div class="proxy-overlay" id="proxyOverlay" style="display:none;">
<div class="proxy-bar">
  <button class="proxy-close" onclick="document.getElementById('proxyOverlay').style.display='none'">‚úï Close</button>
</div>

    <div class="proxy-placeholder" id="proxyPlaceholder">Type a URL above and press Go</div>
<iframe class="proxy-iframe" id="proxyFrame" style="display:none"
  allow="camera; microphone; fullscreen; clipboard-read; clipboard-write"
  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-popups-to-escape-sandbox allow-top-navigation">
</iframe>

  </div>

  <script>
    // ‚úèÔ∏è Replace this with your Cloudflare Worker URL once deployed
const PROXYBASE = 'interstellar-one-umber.vercel.app';

function openProxy() {
  const overlay = document.getElementById('proxyOverlay');
  overlay.style.display = 'flex';
  const frame = document.getElementById('proxyFrame');
  if (!frame.src || frame.src === 'about:blank' || frame.src === '') {
    frame.src = PROXYBASE;
    frame.style.display = 'block';
    document.getElementById('proxyPlaceholder').style.display = 'none';
  }
}

function proxyGo() {
  let url = document.getElementById('proxyInput').value.trim();
  if (!url) return;
  if (!url.startsWith('http') && !url.startsWith('https')) url = 'https://' + url;
  document.getElementById('proxyFrame').src = PROXYBASE + '?url=' + encodeURIComponent(url);
  document.getElementById('proxyFrame').style.display = 'block';
  document.getElementById('proxyPlaceholder').style.display = 'none';
}

  </script>
</body>
</html>















